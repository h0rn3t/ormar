{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ormar Overview The ormar package is an async mini ORM for Python, with support for Postgres, MySQL , and SQLite . The main benefit of using ormar are: getting an async ORM that can be used with async frameworks (fastapi, starlette etc.) getting just one model to maintain - you don't have to maintain pydantic and other orm model (sqlalchemy, peewee, gino etc.) The goal was to create a simple ORM that can be used directly (as request and response models) with fastapi that bases it's data validation on pydantic. Ormar - apart form obvious ORM in name - get it's name from ormar in swedish which means snakes, and ormar(e) in italian which means cabinet. And what's a better name for python ORM than snakes cabinet :) Documentation Check out the documentation for details. Dependencies Ormar is built with: SQLAlchemy core for query building. databases for cross-database async support. pydantic for data validation. typing_extensions for python 3.6 - 3.7 Migrations Because ormar is built on SQLAlchemy core, you can use alembic to provide database migrations. ormar is still under development: We recommend pinning any dependencies (with i.e. ormar~=0.5.2 ) Quick Start Note : Use ipython to try this from the console, since it supports await . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database # note that type hints are optional so # id = ormar.Integer(primary_key=True) # is also valid id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () # Create some records to work with. malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) await Track . objects . create ( album = malibu , title = \"Heart don't stand a chance\" , position = 2 ) await Track . objects . create ( album = malibu , title = \"The Waters\" , position = 3 ) # alternative creation of object divided into 2 steps fantasies = Album ( name = \"Fantasies\" ) await fantasies . save () await Track . objects . create ( album = fantasies , title = \"Help I'm Alive\" , position = 1 ) await Track . objects . create ( album = fantasies , title = \"Sick Muse\" , position = 2 ) # Fetch an instance, without loading a foreign key relationship on it. track = await Track . objects . get ( title = \"The Bird\" ) # We have an album instance, but it only has the primary key populated print ( track . album ) # Album(id=1) [sparse] print ( track . album . pk ) # 1 print ( track . album . name ) # None # Load the relationship from the database await track . album . load () assert track . album . name == \"Malibu\" # This time, fetch an instance, loading the foreign key relationship. track = await Track . objects . select_related ( \"album\" ) . get ( title = \"The Bird\" ) assert track . album . name == \"Malibu\" # By default you also get a second side of the relation # constructed as lowercase source model name +'s' (tracks in this case) # you can also provide custom name with parameter related_name album = await Album . objects . select_related ( \"tracks\" ) . all () assert len ( album . tracks ) == 3 # Fetch instances, with a filter across an FK relationship. tracks = Track . objects . filter ( album__name = \"Fantasies\" ) assert len ( tracks ) == 2 # Fetch instances, with a filter and operator across an FK relationship. tracks = Track . objects . filter ( album__name__iexact = \"fantasies\" ) assert len ( tracks ) == 2 # Limit a query tracks = await Track . objects . limit ( 1 ) . all () assert len ( tracks ) == 1 Ormar Specification QuerySet methods create(**kwargs): -> Model get(**kwargs): -> Model get_or_create(**kwargs) -> Model update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None bulk_update(objects: List[Model], columns: List[str] = None) -> None delete(each: bool = False, **kwargs) -> int all(**kwargs) -> List[Optional[Model]] filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet count() -> int exists() -> bool fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet Relation types One to many - with ForeignKey(to: Model) Many to many - with ManyToMany(to: Model, through: Model) Model fields types Available Model Fields (with required args - optional ones in docs): String(max_length) Text() Boolean() Integer() Float() Date() Time() DateTime() JSON() BigInteger() Decimal(scale, precision) UUID() ForeignKey(to) ManyToMany(to, through) Available fields options The following keyword arguments are supported on all field types. primary_key: bool nullable: bool default: Any server_default: Any index: bool unique: bool choices: typing.Sequence name: str pydantic_only: bool All fields are required unless one of the following is set: nullable - Creates a nullable column. Sets the default to None . default - Set a default value for the field. server_default - Set a default value for the field on server side (like sqlalchemy's func.now() ). primary key with autoincrement - When a column is set to primary key and autoincrement is set on this column. Autoincrement is set by default on int primary keys. pydantic_only - Field is available only as normal pydantic field, not stored in the database. Available signals Signals allow to trigger your function for a given event on a given Model. pre_save post_save pre_update post_update pre_delete post_delete","title":"Overview"},{"location":"#ormar","text":"","title":"ormar"},{"location":"#overview","text":"The ormar package is an async mini ORM for Python, with support for Postgres, MySQL , and SQLite . The main benefit of using ormar are: getting an async ORM that can be used with async frameworks (fastapi, starlette etc.) getting just one model to maintain - you don't have to maintain pydantic and other orm model (sqlalchemy, peewee, gino etc.) The goal was to create a simple ORM that can be used directly (as request and response models) with fastapi that bases it's data validation on pydantic. Ormar - apart form obvious ORM in name - get it's name from ormar in swedish which means snakes, and ormar(e) in italian which means cabinet. And what's a better name for python ORM than snakes cabinet :)","title":"Overview"},{"location":"#documentation","text":"Check out the documentation for details.","title":"Documentation"},{"location":"#dependencies","text":"Ormar is built with: SQLAlchemy core for query building. databases for cross-database async support. pydantic for data validation. typing_extensions for python 3.6 - 3.7","title":"Dependencies"},{"location":"#migrations","text":"Because ormar is built on SQLAlchemy core, you can use alembic to provide database migrations. ormar is still under development: We recommend pinning any dependencies (with i.e. ormar~=0.5.2 )","title":"Migrations"},{"location":"#quick-start","text":"Note : Use ipython to try this from the console, since it supports await . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database # note that type hints are optional so # id = ormar.Integer(primary_key=True) # is also valid id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () # Create some records to work with. malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) await Track . objects . create ( album = malibu , title = \"Heart don't stand a chance\" , position = 2 ) await Track . objects . create ( album = malibu , title = \"The Waters\" , position = 3 ) # alternative creation of object divided into 2 steps fantasies = Album ( name = \"Fantasies\" ) await fantasies . save () await Track . objects . create ( album = fantasies , title = \"Help I'm Alive\" , position = 1 ) await Track . objects . create ( album = fantasies , title = \"Sick Muse\" , position = 2 ) # Fetch an instance, without loading a foreign key relationship on it. track = await Track . objects . get ( title = \"The Bird\" ) # We have an album instance, but it only has the primary key populated print ( track . album ) # Album(id=1) [sparse] print ( track . album . pk ) # 1 print ( track . album . name ) # None # Load the relationship from the database await track . album . load () assert track . album . name == \"Malibu\" # This time, fetch an instance, loading the foreign key relationship. track = await Track . objects . select_related ( \"album\" ) . get ( title = \"The Bird\" ) assert track . album . name == \"Malibu\" # By default you also get a second side of the relation # constructed as lowercase source model name +'s' (tracks in this case) # you can also provide custom name with parameter related_name album = await Album . objects . select_related ( \"tracks\" ) . all () assert len ( album . tracks ) == 3 # Fetch instances, with a filter across an FK relationship. tracks = Track . objects . filter ( album__name = \"Fantasies\" ) assert len ( tracks ) == 2 # Fetch instances, with a filter and operator across an FK relationship. tracks = Track . objects . filter ( album__name__iexact = \"fantasies\" ) assert len ( tracks ) == 2 # Limit a query tracks = await Track . objects . limit ( 1 ) . all () assert len ( tracks ) == 1","title":"Quick Start"},{"location":"#ormar-specification","text":"","title":"Ormar Specification"},{"location":"#queryset-methods","text":"create(**kwargs): -> Model get(**kwargs): -> Model get_or_create(**kwargs) -> Model update(each: bool = False, **kwargs) -> int update_or_create(**kwargs) -> Model bulk_create(objects: List[Model]) -> None bulk_update(objects: List[Model], columns: List[str] = None) -> None delete(each: bool = False, **kwargs) -> int all(**kwargs) -> List[Optional[Model]] filter(**kwargs) -> QuerySet exclude(**kwargs) -> QuerySet select_related(related: Union[List, str]) -> QuerySet prefetch_related(related: Union[List, str]) -> QuerySet limit(limit_count: int) -> QuerySet offset(offset: int) -> QuerySet count() -> int exists() -> bool fields(columns: Union[List, str, set, dict]) -> QuerySet exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet order_by(columns:Union[List, str]) -> QuerySet","title":"QuerySet methods"},{"location":"#relation-types","text":"One to many - with ForeignKey(to: Model) Many to many - with ManyToMany(to: Model, through: Model)","title":"Relation types"},{"location":"#model-fields-types","text":"Available Model Fields (with required args - optional ones in docs): String(max_length) Text() Boolean() Integer() Float() Date() Time() DateTime() JSON() BigInteger() Decimal(scale, precision) UUID() ForeignKey(to) ManyToMany(to, through)","title":"Model fields types"},{"location":"#available-fields-options","text":"The following keyword arguments are supported on all field types. primary_key: bool nullable: bool default: Any server_default: Any index: bool unique: bool choices: typing.Sequence name: str pydantic_only: bool All fields are required unless one of the following is set: nullable - Creates a nullable column. Sets the default to None . default - Set a default value for the field. server_default - Set a default value for the field on server side (like sqlalchemy's func.now() ). primary key with autoincrement - When a column is set to primary key and autoincrement is set on this column. Autoincrement is set by default on int primary keys. pydantic_only - Field is available only as normal pydantic field, not stored in the database.","title":"Available fields options"},{"location":"#available-signals","text":"Signals allow to trigger your function for a given event on a given Model. pre_save post_save pre_update post_update pre_delete post_delete","title":"Available signals"},{"location":"contributing/","text":"All contributions to ormar are welcomed! Issues To make it as simple as possible for us to help you, please include the following: OS python version ormar version database backend (mysql, sqlite or postgresql) Please try to always include the above unless you're unable to install ormar or know it's not relevant to your question or feature request. Pull Requests It should be quite straight forward to get started and create a Pull Request. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , and git installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/ormar.git cd ormar # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install ormar, dependencies and test dependencies pip install -r requirements.txt # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Formatting and linting # ormar uses black for formatting, flake8 for linting and mypy for type hints check # run all of the following as all those calls will be run on travis after every push black ormar tests flake8 ormar mypy --config-file mypy.ini ormar tests # 6. Run tests # on localhost all tests are run against sglite backend # rest of the backends will be checked after push pytest -svv --cov = ormar --cov = tests --cov-fail-under = 100 --cov-report = term-missing # 7. Build documentation mkdocs build # if you have changed the documentation make sure it builds successfully # you can also use `mkdocs serve` to serve the documentation at localhost:8000 # ... commit, push, and create your pull request","title":"Contributing"},{"location":"contributing/#issues","text":"To make it as simple as possible for us to help you, please include the following: OS python version ormar version database backend (mysql, sqlite or postgresql) Please try to always include the above unless you're unable to install ormar or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"It should be quite straight forward to get started and create a Pull Request. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. To make contributing as easy and fast as possible, you'll want to run tests and linting locally. You'll need to have python 3.6 , 3.7 , or 3.8 , virtualenv , and git installed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 1. clone your fork and cd into the repo directory git clone git@github.com:<your username>/ormar.git cd ormar # 2. Set up a virtualenv for running tests virtualenv -p ` which python3.7 ` env source env/bin/activate # (or however you prefer to setup a python environment, 3.6 will work too) # 3. Install ormar, dependencies and test dependencies pip install -r requirements.txt # 4. Checkout a new branch and make your changes git checkout -b my-new-feature-branch # make your changes... # 5. Formatting and linting # ormar uses black for formatting, flake8 for linting and mypy for type hints check # run all of the following as all those calls will be run on travis after every push black ormar tests flake8 ormar mypy --config-file mypy.ini ormar tests # 6. Run tests # on localhost all tests are run against sglite backend # rest of the backends will be checked after push pytest -svv --cov = ormar --cov = tests --cov-fail-under = 100 --cov-report = term-missing # 7. Build documentation mkdocs build # if you have changed the documentation make sure it builds successfully # you can also use `mkdocs serve` to serve the documentation at localhost:8000 # ... commit, push, and create your pull request","title":"Pull Requests"},{"location":"fastapi/","text":"The use of ormar with fastapi is quite simple. Apart from connecting to databases at startup everything else you need to do is substitute pydantic models with ormar models. Here you can find a very simple sample application code. Warning This example assumes that you already have a database created. If that is not the case please visit database initialization section. Imports and initialization First take care of the imports and initialization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Database connection Next define startup and shutdown events (or use middleware) - note that this is databases specific setting not the ormar one 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Info You can read more on connecting to databases in fastapi documentation Models definition Define ormar models with appropriate fields. Those models will be used insted of pydantic ones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Tip You can read more on defining Models in models section. Fastapi endpoints definition Define your desired endpoints, note how ormar models are used both as response_model and as a requests parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Note Note how ormar Model methods like save() are available straight out of the box after fastapi initializes it for you. Note Note that you can return a Model (or list of Models ) directly - fastapi will jsonize it for you Test the application Run fastapi If you want to run this script and play with fastapi swagger install uvicorn first pip install uvicorn And launch the fastapi. uvicorn <filename_without_extension>:app --reload Now you can navigate to your browser (by default fastapi address is 127.0.0.1:8000/docs ) and play with the api. Info You can read more about running fastapi in fastapi docs. Test with pytest Here you have a sample test that will prove that everything works as intended. Be sure to create the tables first. If you are using pytest you can use a fixture. 1 2 3 4 5 6 @pytest . fixture ( autouse = True , scope = \"module\" ) def create_test_database (): engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) yield metadata . drop_all ( engine ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # here is a sample test to check the working of the ormar with fastapi from starlette.testclient import TestClient def test_all_endpoints (): # note that TestClient is only sync, don't use asyns here client = TestClient ( app ) # note that you need to connect to database manually # or use client as contextmanager during tests with client as client : response = client . post ( \"/categories/\" , json = { \"name\" : \"test cat\" }) category = response . json () response = client . post ( \"/items/\" , json = { \"name\" : \"test\" , \"id\" : 1 , \"category\" : category } ) item = Item ( ** response . json ()) assert item . pk is not None response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] == item item . name = \"New name\" response = client . put ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () == item . dict () response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] . name == \"New name\" response = client . delete ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () . get ( \"deleted_rows\" , \"__UNDEFINED__\" ) != \"__UNDEFINED__\" response = client . get ( \"/items/\" ) items = response . json () assert len ( items ) == 0 Tip If you want to see more test cases and how to test ormar/fastapi see tests directory in the github repo Info You can read more on testing fastapi in fastapi docs.","title":"Use with Fastapi"},{"location":"fastapi/#imports-and-initialization","text":"First take care of the imports and initialization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()}","title":"Imports and initialization"},{"location":"fastapi/#database-connection","text":"Next define startup and shutdown events (or use middleware) - note that this is databases specific setting not the ormar one 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Info You can read more on connecting to databases in fastapi documentation","title":"Database connection"},{"location":"fastapi/#models-definition","text":"Define ormar models with appropriate fields. Those models will be used insted of pydantic ones. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Tip You can read more on defining Models in models section.","title":"Models definition"},{"location":"fastapi/#fastapi-endpoints-definition","text":"Define your desired endpoints, note how ormar models are used both as response_model and as a requests parameters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from typing import List , Optional import databases import sqlalchemy from fastapi import FastAPI import ormar app = FastAPI () metadata = sqlalchemy . MetaData () database = databases . Database ( \"sqlite:///test.db\" ) app . state . database = database @app . on_event ( \"startup\" ) async def startup () -> None : database_ = app . state . database if not database_ . is_connected : await database_ . connect () @app . on_event ( \"shutdown\" ) async def shutdown () -> None : database_ = app . state . database if database_ . is_connected : await database_ . disconnect () class Category ( ormar . Model ): class Meta : tablename = \"categories\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Item ( ormar . Model ): class Meta : tablename = \"items\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) category : Optional [ Category ] = ormar . ForeignKey ( Category , nullable = True ) @app . get ( \"/items/\" , response_model = List [ Item ]) async def get_items (): items = await Item . objects . select_related ( \"category\" ) . all () return items @app . post ( \"/items/\" , response_model = Item ) async def create_item ( item : Item ): await item . save () return item @app . post ( \"/categories/\" , response_model = Category ) async def create_category ( category : Category ): await category . save () return category @app . put ( \"/items/ {item_id} \" ) async def get_item ( item_id : int , item : Item ): item_db = await Item . objects . get ( pk = item_id ) return await item_db . update ( ** item . dict ()) @app . delete ( \"/items/ {item_id} \" ) async def delete_item ( item_id : int , item : Item = None ): if item : return { \"deleted_rows\" : await item . delete ()} item_db = await Item . objects . get ( pk = item_id ) return { \"deleted_rows\" : await item_db . delete ()} Note Note how ormar Model methods like save() are available straight out of the box after fastapi initializes it for you. Note Note that you can return a Model (or list of Models ) directly - fastapi will jsonize it for you","title":"Fastapi endpoints definition"},{"location":"fastapi/#test-the-application","text":"","title":"Test the application"},{"location":"fastapi/#run-fastapi","text":"If you want to run this script and play with fastapi swagger install uvicorn first pip install uvicorn And launch the fastapi. uvicorn <filename_without_extension>:app --reload Now you can navigate to your browser (by default fastapi address is 127.0.0.1:8000/docs ) and play with the api. Info You can read more about running fastapi in fastapi docs.","title":"Run fastapi"},{"location":"fastapi/#test-with-pytest","text":"Here you have a sample test that will prove that everything works as intended. Be sure to create the tables first. If you are using pytest you can use a fixture. 1 2 3 4 5 6 @pytest . fixture ( autouse = True , scope = \"module\" ) def create_test_database (): engine = sqlalchemy . create_engine ( DATABASE_URL ) metadata . create_all ( engine ) yield metadata . drop_all ( engine ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # here is a sample test to check the working of the ormar with fastapi from starlette.testclient import TestClient def test_all_endpoints (): # note that TestClient is only sync, don't use asyns here client = TestClient ( app ) # note that you need to connect to database manually # or use client as contextmanager during tests with client as client : response = client . post ( \"/categories/\" , json = { \"name\" : \"test cat\" }) category = response . json () response = client . post ( \"/items/\" , json = { \"name\" : \"test\" , \"id\" : 1 , \"category\" : category } ) item = Item ( ** response . json ()) assert item . pk is not None response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] == item item . name = \"New name\" response = client . put ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () == item . dict () response = client . get ( \"/items/\" ) items = [ Item ( ** item ) for item in response . json ()] assert items [ 0 ] . name == \"New name\" response = client . delete ( f \"/items/ { item . pk } \" , json = item . dict ()) assert response . json () . get ( \"deleted_rows\" , \"__UNDEFINED__\" ) != \"__UNDEFINED__\" response = client . get ( \"/items/\" ) items = response . json () assert len ( items ) == 0 Tip If you want to see more test cases and how to test ormar/fastapi see tests directory in the github repo Info You can read more on testing fastapi in fastapi docs.","title":"Test with pytest"},{"location":"fields/","text":"Fields There are 12 basic model field types and a special ForeignKey and Many2Many fields to establish relationships between models. Tip For explanation of ForeignKey and Many2Many fields check relations . Each of the Fields has assigned both sqlalchemy column class and python type that is used to create pydantic model. Common Parameters All Field types have a set of common parameters. primary_key primary_key : bool = False -> by default False. Sets the primary key column on a table, foreign keys always refer to the pk of the Model . Used in sql only. autoincrement autoincrement : bool = primary_key and type == int -> defaults to True if column is a primary key and of type Integer, otherwise False. Can be only used with int/bigint fields. If a field has autoincrement it becomes optional. Used both in sql and pydantic (changes pk field to optional for autoincrement). nullable nullable : bool = not primary_key -> defaults to False for primary key column, and True for all other. Specifies if field is optional or required, used both with sql and pydantic. Note By default all ForeignKeys are also nullable, meaning the related Model is not required. If you change the ForeignKey column to nullable=False , it becomes required. Info If you want to know more about how you can preload related models during queries and how the relations work read the queries and relations sections. default default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on an insert, used during pydantic model definition. If the field has a default value it becomes optional. You can pass a static value or a Callable (function etc.) Used both in sql and pydantic. server default server_default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on the server side so you can pass i.e. sql function (like now() or query/value wrapped in sqlalchemy text() clause). If the field has a server_default value it becomes optional. You can pass a static value or a Callable (function etc.) Used in sql only. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from datetime import datetime import databases import sqlalchemy from sqlalchemy import func , text import ormar database = databases . Database ( \"sqlite:///test.db\" ) metadata = sqlalchemy . MetaData () class Product ( ormar . Model ): class Meta : tablename = \"product\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) company : str = ormar . String ( max_length = 200 , server_default = \"Acme\" ) sort_order : int = ormar . Integer ( server_default = text ( \"10\" )) created : datetime = ormar . DateTime ( server_default = func . now ()) Warning server_default accepts str , sqlalchemy.sql.elements.ClauseElement or sqlalchemy.sql.elements.TextClause so if you want to set i.e. Integer value you need to wrap it in sqlalchemy.text() function like above Tip You can pass also valid sql (dialect specific) wrapped in sqlalchemy.text() For example func.now() above could be exchanged for text('(CURRENT_TIMESTAMP)') for sqlite backend Info server_default is passed straight to sqlalchemy table definition so you can read more in server default sqlalchemy documentation index index : bool = False -> by default False, Sets the index on a table's column. Used in sql only. unique unique : bool = False Sets the unique constraint on a table's column. Used in sql only. pydantic_only pydantic_only : bool = False Prevents creation of a sql column for given field. Used for data related to given model but not to be stored in the database. Used in pydantic only. choices choices : Sequence = [] A set of choices allowed to be used for given field. Used for data validation on pydantic side. Prevents insertion of value not present in the choices list. Used in pydantic only. Fields Types String String(max_length, allow_blank: bool = True, strip_whitespace: bool = False, min_length: int = None, max_length: int = None, curtail_length: int = None, regex: str = None,) has a required max_length parameter. Sqlalchemy column: sqlalchemy.String Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation. Text Text(allow_blank: bool = True, strip_whitespace: bool = False) has no required parameters. Sqlalchemy column: sqlalchemy.Text Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation. Boolean Boolean() has no required parameters. Sqlalchemy column: sqlalchemy.Boolean Type (used for pydantic): bool Integer Integer(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Integer Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation. BigInteger BigInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.BigInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation. Float Float(minimum: float = None, maximum: float = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Float Type (used for pydantic): float Tip For explanation of other parameters check pydantic documentation. Decimal Decimal(minimum: float = None, maximum: float = None, multiple_of: int = None, precision: int = None, scale: int = None, max_digits: int = None, decimal_places: int = None) has no required parameters You can use either length and precision parameters or max_digits and decimal_places . Sqlalchemy column: sqlalchemy.DECIMAL Type (used for pydantic): decimal.Decimal Tip For explanation of other parameters check pydantic documentation. Date Date() has no required parameters. Sqlalchemy column: sqlalchemy.Date Type (used for pydantic): datetime.date Time Time() has no required parameters. Sqlalchemy column: sqlalchemy.Time Type (used for pydantic): datetime.time DateTime DateTime() has no required parameters. Sqlalchemy column: sqlalchemy.DateTime Type (used for pydantic): datetime.datetime JSON JSON() has no required parameters. Sqlalchemy column: sqlalchemy.JSON Type (used for pydantic): pydantic.Json UUID UUID(uuid_format: str = 'hex') has no required parameters. Sqlalchemy column: ormar.UUID based on sqlalchemy.CHAR(36) or sqlalchemy.CHAR(32) field (for string or hex format respectively) Type (used for pydantic): uuid.UUID uuid_format parameters allow 'hex'(default) or 'string' values. Depending on the format either 32 or 36 char is used in the database. Sample: * 'hex' format value = \"c616ab438cce49dbbf4380d109251dce\" (CHAR(32)) * 'string' value = \"c616ab43-8cce-49db-bf43-80d109251dce\" (CHAR(36)) When loaded it's always python UUID so you can compare it and compare two formats values between each other.","title":"Fields"},{"location":"fields/#fields","text":"There are 12 basic model field types and a special ForeignKey and Many2Many fields to establish relationships between models. Tip For explanation of ForeignKey and Many2Many fields check relations . Each of the Fields has assigned both sqlalchemy column class and python type that is used to create pydantic model.","title":"Fields"},{"location":"fields/#common-parameters","text":"All Field types have a set of common parameters.","title":"Common Parameters"},{"location":"fields/#primary_key","text":"primary_key : bool = False -> by default False. Sets the primary key column on a table, foreign keys always refer to the pk of the Model . Used in sql only.","title":"primary_key"},{"location":"fields/#autoincrement","text":"autoincrement : bool = primary_key and type == int -> defaults to True if column is a primary key and of type Integer, otherwise False. Can be only used with int/bigint fields. If a field has autoincrement it becomes optional. Used both in sql and pydantic (changes pk field to optional for autoincrement).","title":"autoincrement"},{"location":"fields/#nullable","text":"nullable : bool = not primary_key -> defaults to False for primary key column, and True for all other. Specifies if field is optional or required, used both with sql and pydantic. Note By default all ForeignKeys are also nullable, meaning the related Model is not required. If you change the ForeignKey column to nullable=False , it becomes required. Info If you want to know more about how you can preload related models during queries and how the relations work read the queries and relations sections.","title":"nullable"},{"location":"fields/#default","text":"default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on an insert, used during pydantic model definition. If the field has a default value it becomes optional. You can pass a static value or a Callable (function etc.) Used both in sql and pydantic.","title":"default"},{"location":"fields/#server-default","text":"server_default : Any = None -> defaults to None. A default value used if no other value is passed. In sql invoked on the server side so you can pass i.e. sql function (like now() or query/value wrapped in sqlalchemy text() clause). If the field has a server_default value it becomes optional. You can pass a static value or a Callable (function etc.) Used in sql only. Sample usage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from datetime import datetime import databases import sqlalchemy from sqlalchemy import func , text import ormar database = databases . Database ( \"sqlite:///test.db\" ) metadata = sqlalchemy . MetaData () class Product ( ormar . Model ): class Meta : tablename = \"product\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) company : str = ormar . String ( max_length = 200 , server_default = \"Acme\" ) sort_order : int = ormar . Integer ( server_default = text ( \"10\" )) created : datetime = ormar . DateTime ( server_default = func . now ()) Warning server_default accepts str , sqlalchemy.sql.elements.ClauseElement or sqlalchemy.sql.elements.TextClause so if you want to set i.e. Integer value you need to wrap it in sqlalchemy.text() function like above Tip You can pass also valid sql (dialect specific) wrapped in sqlalchemy.text() For example func.now() above could be exchanged for text('(CURRENT_TIMESTAMP)') for sqlite backend Info server_default is passed straight to sqlalchemy table definition so you can read more in server default sqlalchemy documentation","title":"server default"},{"location":"fields/#index","text":"index : bool = False -> by default False, Sets the index on a table's column. Used in sql only.","title":"index"},{"location":"fields/#unique","text":"unique : bool = False Sets the unique constraint on a table's column. Used in sql only.","title":"unique"},{"location":"fields/#pydantic_only","text":"pydantic_only : bool = False Prevents creation of a sql column for given field. Used for data related to given model but not to be stored in the database. Used in pydantic only.","title":"pydantic_only"},{"location":"fields/#choices","text":"choices : Sequence = [] A set of choices allowed to be used for given field. Used for data validation on pydantic side. Prevents insertion of value not present in the choices list. Used in pydantic only.","title":"choices"},{"location":"fields/#fields-types","text":"","title":"Fields Types"},{"location":"fields/#string","text":"String(max_length, allow_blank: bool = True, strip_whitespace: bool = False, min_length: int = None, max_length: int = None, curtail_length: int = None, regex: str = None,) has a required max_length parameter. Sqlalchemy column: sqlalchemy.String Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation.","title":"String"},{"location":"fields/#text","text":"Text(allow_blank: bool = True, strip_whitespace: bool = False) has no required parameters. Sqlalchemy column: sqlalchemy.Text Type (used for pydantic): str Tip For explanation of other parameters check pydantic documentation.","title":"Text"},{"location":"fields/#boolean","text":"Boolean() has no required parameters. Sqlalchemy column: sqlalchemy.Boolean Type (used for pydantic): bool","title":"Boolean"},{"location":"fields/#integer","text":"Integer(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Integer Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation.","title":"Integer"},{"location":"fields/#biginteger","text":"BigInteger(minimum: int = None, maximum: int = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.BigInteger Type (used for pydantic): int Tip For explanation of other parameters check pydantic documentation.","title":"BigInteger"},{"location":"fields/#float","text":"Float(minimum: float = None, maximum: float = None, multiple_of: int = None) has no required parameters. Sqlalchemy column: sqlalchemy.Float Type (used for pydantic): float Tip For explanation of other parameters check pydantic documentation.","title":"Float"},{"location":"fields/#decimal","text":"Decimal(minimum: float = None, maximum: float = None, multiple_of: int = None, precision: int = None, scale: int = None, max_digits: int = None, decimal_places: int = None) has no required parameters You can use either length and precision parameters or max_digits and decimal_places . Sqlalchemy column: sqlalchemy.DECIMAL Type (used for pydantic): decimal.Decimal Tip For explanation of other parameters check pydantic documentation.","title":"Decimal"},{"location":"fields/#date","text":"Date() has no required parameters. Sqlalchemy column: sqlalchemy.Date Type (used for pydantic): datetime.date","title":"Date"},{"location":"fields/#time","text":"Time() has no required parameters. Sqlalchemy column: sqlalchemy.Time Type (used for pydantic): datetime.time","title":"Time"},{"location":"fields/#datetime","text":"DateTime() has no required parameters. Sqlalchemy column: sqlalchemy.DateTime Type (used for pydantic): datetime.datetime","title":"DateTime"},{"location":"fields/#json","text":"JSON() has no required parameters. Sqlalchemy column: sqlalchemy.JSON Type (used for pydantic): pydantic.Json","title":"JSON"},{"location":"fields/#uuid","text":"UUID(uuid_format: str = 'hex') has no required parameters. Sqlalchemy column: ormar.UUID based on sqlalchemy.CHAR(36) or sqlalchemy.CHAR(32) field (for string or hex format respectively) Type (used for pydantic): uuid.UUID uuid_format parameters allow 'hex'(default) or 'string' values. Depending on the format either 32 or 36 char is used in the database. Sample: * 'hex' format value = \"c616ab438cce49dbbf4380d109251dce\" (CHAR(32)) * 'string' value = \"c616ab43-8cce-49db-bf43-80d109251dce\" (CHAR(36)) When loaded it's always python UUID so you can compare it and compare two formats values between each other.","title":"UUID"},{"location":"install/","text":"Installation Installation is as simple as: 1 pip install ormar Dependencies Ormar uses databases for connectivity issues, pydantic for validation and sqlalchemy-core for queries. All three should install along the installation of ormar if not present at your system before. databases pydantic>=1.5 sqlalchemy Optional dependencies ormar has three optional dependencies based on database backend you use: Postgresql 1 pip install ormar [ postgresql ] Will install also asyncpg and psycopg2 . Mysql 1 pip install ormar [ mysql ] Will install also aiomysql and pymysql . Sqlite 1 pip install ormar [ sqlite ] Will install also aiosqlite . Manual installation of dependencies Of course, you can also install these requirements manually with pip install asyncpg etc.","title":"Installation"},{"location":"install/#installation","text":"Installation is as simple as: 1 pip install ormar","title":"Installation"},{"location":"install/#dependencies","text":"Ormar uses databases for connectivity issues, pydantic for validation and sqlalchemy-core for queries. All three should install along the installation of ormar if not present at your system before. databases pydantic>=1.5 sqlalchemy","title":"Dependencies"},{"location":"install/#optional-dependencies","text":"ormar has three optional dependencies based on database backend you use:","title":"Optional dependencies"},{"location":"install/#postgresql","text":"1 pip install ormar [ postgresql ] Will install also asyncpg and psycopg2 .","title":"Postgresql"},{"location":"install/#mysql","text":"1 pip install ormar [ mysql ] Will install also aiomysql and pymysql .","title":"Mysql"},{"location":"install/#sqlite","text":"1 pip install ormar [ sqlite ] Will install also aiosqlite .","title":"Sqlite"},{"location":"install/#manual-installation-of-dependencies","text":"Of course, you can also install these requirements manually with pip install asyncpg etc.","title":"Manual installation of dependencies"},{"location":"models/","text":"Models Defining models By defining an ormar Model you get corresponding Pydantic model as well as Sqlalchemy table for free. They are being managed in the background and you do not have to create them on your own. Model Class To build an ormar model you simply need to inherit a ormar.Model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Defining Fields Next assign one or more of the Fields as a class level variables. Basic Field Types Each table has to have a primary key column, which you specify by setting primary_key=True on selected field. Only one primary key column is allowed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Warning Not assigning primary_key column or assigning more than one column per Model will raise ModelDefinitionError exception. By default if you assign primary key to Integer field, the autoincrement option is set to true. You can disable by passing autoincremant=False . 1 id : int = ormar . Integer ( primary_key = True , autoincrement = False ) Non Database Fields Note that if you need a normal pydantic field in your model (used to store value on model or pass around some value) you can define a field with parameter pydantic_only=True . Fields created like this are added to the pydantic model fields -> so are subject to validation according to Field type, also appear in dict() and json() result. The difference is that those fields are not saved in the database . So they won't be included in underlying sqlalchemy columns , or table variables (check Internals section below to see how you can access those if you need). Subsequently pydantic_only fields won't be included in migrations or any database operation (like save , update etc.) Fields like those can be passed around into payload in fastapi request and will be returned in fastapi response (of course only if you set their value somewhere in your code as the value is not fetched from the db. If you pass a value in fastapi request and return the same instance that fastapi constructs for you in request_model you should get back exactly same value in response .). Warning pydantic_only=True fields are always Optional and it cannot be changed (otherwise db load validation would fail) Tip pydantic_only=True fields are a good solution if you need to pass additional information from outside of your API (i.e. frontend). They are not stored in db but you can access them in your APIRoute code and they also have pydantic validation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) non_db_field : str = ormar . String ( max_length = 100 , pydantic_only = True ) If you combine pydantic_only=True field with default parameter and do not pass actual value in request you will always get default value. Since it can be a function you can set default=datetime.datetime.now and get current timestamp each time you call an endpoint etc. Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==part of code removed for clarity==> class User ( ormar . Model ): class Meta : tablename : str = \"users2\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 , nullable = False ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , nullable = True ) timestamp : datetime . datetime = ormar . DateTime ( pydantic_only = True , default = datetime . datetime . now ) # <==part of code removed for clarity==> app = FastAPI () @app . post ( \"/users/\" ) async def create_user ( user : User ): return await user . save () # <==part of code removed for clarity==> def test_excluding_fields_in_endpoints (): client = TestClient ( app ) with client as client : timestamp = datetime . datetime . now () user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"timestamp\" : str ( timestamp ), } response = client . post ( \"/users/\" , json = user ) assert list ( response . json () . keys ()) == [ \"id\" , \"email\" , \"first_name\" , \"last_name\" , \"category\" , \"timestamp\" , ] # returned is the same timestamp assert response . json () . get ( \"timestamp\" ) == str ( timestamp ) . replace ( \" \" , \"T\" ) # <==part of code removed for clarity==> Property fields Sometimes it's desirable to do some kind of calculation on the model instance. One of the most common examples can be concatenating two or more fields. Imagine you have first_name and last_name fields on your model, but would like to have full_name in the result of the fastapi query. You can create a new pydantic model with a method that accepts only self (so like default python @property ) and populate it in your code. But it's so common that ormar has you covered. You can \"materialize\" a property_field on you Model . Warning property_field fields are always Optional and it cannot be changed (otherwise db load validation would fail) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar from ormar import property_field database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) @property_field def prefixed_name ( self ): return 'custom_prefix__' + self . name Warning The decorated function has to accept only one parameter, and that parameter have to be self . If you try to decorate a function with more parameters ormar will raise ModelDefinitionError . Sample: 1 2 3 4 5 6 7 8 9 10 # will raise ModelDefinitionError @property_field def prefixed_name ( self , prefix = \"prefix_\" ): return 'custom_prefix__' + self . name # will raise ModelDefinitionError # (calling first param something else than 'self' is a bad practice anyway) @property_field def prefixed_name ( instance ): return 'custom_prefix__' + self . name Note that property_field decorated methods do not go through verification (but that might change in future) and are only available in the response from fastapi and dict() and json() methods. You cannot pass a value for this field in the request (or rather you can but it will be discarded by ormar so really no point but no Exception will be raised). Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. Tip Note that @property_field decorator is designed to replace the python @property decorator, you do not have to combine them. In theory you can cause ormar have a failsafe mechanism, but note that i.e. mypy will complain about re-decorating a property. 1 2 3 4 5 # valid and working but unnecessary and mypy will complain @property_field @property def prefixed_name ( self ): return 'custom_prefix__' + self . name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==part of code removed for clarity==> def gen_pass (): # note: NOT production ready choices = string . ascii_letters + string . digits + \"!@#$%^&*()\" return \"\" . join ( random . choice ( choices ) for _ in range ( 20 )) class RandomModel ( ormar . Model ): class Meta : tablename : str = \"random_users\" metadata = metadata database = database include_props_in_dict = True id : int = ormar . Integer ( primary_key = True ) password : str = ormar . String ( max_length = 255 , default = gen_pass ) first_name : str = ormar . String ( max_length = 255 , default = \"John\" ) last_name : str = ormar . String ( max_length = 255 ) created_date : datetime . datetime = ormar . DateTime ( server_default = sqlalchemy . func . now () ) @property_field def full_name ( self ) -> str : return \" \" . join ([ self . first_name , self . last_name ]) # <==part of code removed for clarity==> app = FastAPI () # explicitly exclude property_field in this endpoint @app . post ( \"/random/\" , response_model = RandomModel , response_model_exclude = { \"full_name\" }) async def create_user ( user : RandomModel ): return await user . save () # <==part of code removed for clarity==> def test_excluding_property_field_in_endpoints2 (): client = TestClient ( app ) with client as client : RandomModel . Meta . include_props_in_dict = True user3 = { \"last_name\" : \"Test\" } response = client . post ( \"/random3/\" , json = user3 ) assert list ( response . json () . keys ()) == [ \"id\" , \"password\" , \"first_name\" , \"last_name\" , \"created_date\" , ] # despite being decorated with property_field if you explictly exclude it it will be gone assert response . json () . get ( \"full_name\" ) is None # <==part of code removed for clarity==> Fields names vs Column names By default names of the fields will be used for both the underlying pydantic model and sqlalchemy table. If for whatever reason you prefer to change the name in the database but keep the name in the model you can do this with specifying name parameter during Field declaration Here you have a sample model with changed names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Child ( ormar . Model ): class Meta : tablename = \"children\" metadata = metadata database = database id : int = ormar . Integer ( name = \"child_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year_born\" , nullable = True ) Note that you can also change the ForeignKey column name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from typing import Optional import databases import sqlalchemy import ormar from .docs010 import Artist # previous example database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"music_albums\" metadata = metadata database = database id : int = ormar . Integer ( name = \"album_id\" , primary_key = True ) name : str = ormar . String ( name = \"album_name\" , max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist , name = \"artist_id\" ) But for now you cannot change the ManyToMany column names as they go through other Model anyway. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import sqlalchemy import ormar from .docs008 import Child database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class ArtistChildren ( ormar . Model ): class Meta : tablename = \"children_x_artists\" metadata = metadata database = database class Artist ( ormar . Model ): class Meta : tablename = \"artists\" metadata = metadata database = database id : int = ormar . Integer ( name = \"artist_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) children = ormar . ManyToMany ( Child , through = ArtistChildren ) Type Hints & Legacy Before version 0.4.0 ormar supported only one way of defining Fields on a Model using python type hints as pydantic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () But that didn't play well with static type checkers like mypy and pydantic PyCharm plugin. Therefore from version >=0.4.0 ormar switched to new notation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note that type hints are optional so perfectly valid ormar code can look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Warning Even if you use type hints ormar does not use them to construct pydantic fields! Type hints are there only to support static checkers and linting, ormar construct annotations used by pydantic from own fields. Database initialization/ migrations Note that all examples assume that you already have a database. If that is not the case and you need to create your tables, that's super easy as ormar is using sqlalchemy for underlying table construction. All you have to do is call create_all() like in the example below. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # note that this has to be the same metadata that is used in ormar Models definition metadata . create_all ( engine ) You can also create single tables, sqlalchemy tables are exposed in ormar.Meta class. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # Artist is an ormar model from previous examples Artist . Meta . table . create ( engine ) Warning You need to create the tables only once, so use a python console for that or remove the script from your production code after first use. Likewise as with tables, since we base tables on sqlalchemy for migrations please use alembic . Use command line to reproduce this minimalistic example. 1 2 3 alembic init alembic alembic revision -- autogenerate - m \"made some changes\" alembic upgrade head A quick example of alembic migrations should be something similar to: When you have application structure like: 1 2 3 4 5 -> app -> alembic (initialized folder - so run alembic init alembic inside app folder) -> models (here are the models) -> __init__.py -> my_models.py Your env.py file (in alembic folder) can look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from logging.config import fileConfig from sqlalchemy import create_engine from alembic import context import sys , os # add app folder to system path (alternative is running it from parent folder with python -m ...) myPath = os . path . dirname ( os . path . abspath ( __file__ )) sys . path . insert ( 0 , myPath + '/../../' ) # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context . config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig ( config . config_file_name ) # add your model's MetaData object here (the one used in ormar) # for 'autogenerate' support from app.models.my_models import metadata target_metadata = metadata # set your url here or import from settings # note that by default url is in saved sqlachemy.url variable in alembic.ini file URL = \"sqlite:///test.db\" def run_migrations_offline (): \"\"\"Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the script output. \"\"\" context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () def run_migrations_online (): \"\"\"Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. \"\"\" connectable = create_engine ( URL ) with connectable . connect () as connection : context . configure ( connection = connection , target_metadata = target_metadata , # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () if context . is_offline_mode (): run_migrations_offline () else : run_migrations_online () You can also include/exclude specific tables with include_object parameter passed to context.configure . That should be a function returning True/False for given objects. A sample function excluding tables starting with data_ in name unless it's 'data_jobs': 1 2 3 4 5 def include_object ( object , name , type_ , reflected , compare_to ): if name and name . startswith ( 'data_' ) and name not in [ 'data_jobs' ]: return False return True Note Function parameters for include_objects (you can change the name) are required and defined in alembic to check what they do check the alembic documentation And you pass it into context like (both in online and offline): 1 2 3 4 5 6 7 8 context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, user_module_prefix = 'sa.' , include_object = include_object ) Info You can read more about table creation, altering and migrations in sqlalchemy table creation documentation. Dependencies Since ormar depends on databases and sqlalchemy-core for database connection and table creation you need to assign each Model with two special parameters. Databases One is Database instance created with your database url in sqlalchemy connection string format. Created instance needs to be passed to every Model with Meta class database parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the Database instance only once and use it for all models. You can create several ones if you want to use multiple databases. Sqlalchemy Second dependency is sqlalchemy MetaData instance. Created instance needs to be passed to every Model with Meta class metadata parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the MetaData instance only once and use it for all models. You can create several ones if you want to use multiple databases. Best practice Only thing that ormar expects is a class with name Meta and two class variables: metadata and databases . So instead of providing the same parameters over and over again for all models you should creata a class and subclass it in all models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () # note that you do not have to subclass ModelMeta, # it's useful for type hints and code completion class MainMeta ( ormar . ModelMeta ): metadata = metadata database = database class Artist ( ormar . Model ): class Meta ( MainMeta ): # note that tablename is optional # if not provided ormar will user class.__name__.lower()+'s' # -> artists in this example pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 100 ) last_name : str = ormar . String ( max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) class Album ( ormar . Model ): class Meta ( MainMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist ) Warning You need to subclass your MainMeta class in each Model class as those classes store configuration variables that otherwise would be overwritten by each Model . Table Names By default table name is created from Model class name as lowercase name plus 's'. You can overwrite this parameter by providing Meta class tablename argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : # if you omit this parameter it will be created automatically # as class.__name__.lower()+'s' -> \"courses\" in this example tablename = \"my_courses\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Constraints On a model level you can also set model-wise constraints on sql columns. Right now only UniqueColumns constraint is present. Tip To read more about columns constraints like primary_key , unique , ForeignKey etc. visit fields . You can set this parameter by providing Meta class constraints argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata # define your constraints in Meta class of the model # it's a list that can contain multiple constraints # hera a combination of name and column will have to be unique in db constraints = [ ormar . UniqueColumns ( \"name\" , \"completed\" )] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Model Initialization There are two ways to create and persist the Model instance in the database. Tip Use ipython to try this from the console, since it supports await . If you plan to modify the instance in the later execution of your program you can initiate your Model as a normal class and later await a save() call. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) If you want to initiate your Model and at the same time save in in the database use a QuerySet's method create() . For creating multiple objects at once a bulk_create() QuerySet's method is available. Each model has a QuerySet initialised as objects parameter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) Info To read more about QuerySets (including bulk operations) and available methods visit queries Model save status Each model instance is a separate python object and they do not know anything about each other. 1 2 3 4 5 6 7 8 track1 = await Track . objects . get ( name = 'The Bird' ) track2 = await Track . objects . get ( name = 'The Bird' ) assert track1 == track2 # True track1 . name = 'The Bird2' await track1 . save () assert track1 . name == track2 . name # False # track2 does not update and knows nothing about track1 The objects itself have a saved status, which is set as following: Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantiation with __init__ (w/o QuerySet.create or before calling save ) You can check if model is saved with ModelInstance.saved property Model methods load By default when you query a table without prefetching related models, the ormar will still construct your related models, but populate them only with the pk value. You can load the related model by calling load() method. load() can also be used to refresh the model from the database (if it was changed by some other process). 1 2 3 4 5 6 7 track = await Track . objects . get ( name = 'The Bird' ) track . album . pk # will return malibu album pk (1) track . album . name # will return None # you need to actually load the data first await track . album . load () track . album . name # will return 'Malibu' save save() -> self You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. save() can also be used to persist changes that you made to the model, but only if the primary key is not set or the model does not exist in database. The save() method does not check if the model exists in db, so if it does you will get a integrity error from your selected db backend if trying to save model with already existing primary key. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . save () # will persist the model in database track = await Track . objects . get ( name = 'The Bird' ) await track . save () # will raise integrity error as pk is populated update update(**kwargs) -> self You can update models by using QuerySet.update() method or by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. To persist a newly created model use save() or upsert(**kwargs) methods. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . update ( name = 'The Bird Strikes Again' ) upsert upsert(**kwargs) -> self It's an proxy to either save() or update(**kwargs) methods described above. If the primary key is set -> the update method will be called. If the pk is not set the save() method will be called. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . upsert () # will call save as the pk is empty track = await Track . objects . get ( name = 'The Bird' ) await track . upsert ( name = 'The Bird Strikes Again' ) # will call update as pk is already populated delete You can delete models by using QuerySet.delete() method or by using your model and calling delete() method. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . delete () # will delete the model from database Tip Note that that track object stays the same, only record in the database is removed. save_related save_related(follow: bool = False) -> None Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. To understand when a model is saved check save status section above. By default the save_related method saved only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and save all of them in the relation tree. Warning To avoid circular updates with follow=True set, save_related keeps a set of already visited Models, and won't perform nested save_related on Models that were already visited. So if you have a diamond or circular relations types you need to perform the updates in a manual way. 1 2 # in example like this the second Street (coming from City) won't be save_related, so ZipCode won't be updated Street -> District -> City -> Street -> ZipCode Internals Apart from special parameters defined in the Model during definition (tablename, metadata etc.) the Model provides you with useful internals. Pydantic Model All Model classes inherit from pydantic.BaseModel so you can access all normal attributes of pydantic models. For example to list pydantic model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . __fields__ ) \"\"\" Will produce: {'id': ModelField(name='id', type=Optional[int], required=False, default=None), 'name': ModelField(name='name', type=Optional[str], required=False, default=None), 'completed': ModelField(name='completed', type=bool, required=False, default=False)} \"\"\" Tip Note how the primary key id field is optional as Integer primary key by default has autoincrement set to True . Info For more options visit official pydantic documentation. Sqlalchemy Table To access auto created sqlalchemy table you can use Model.Meta.table parameter For example to list table columns you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): # note you don't have to subclass - but it's recommended for ide completion and mypy database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . Meta . table . columns ) \"\"\" Will produce: ['courses.id', 'courses.name', 'courses.completed'] \"\"\" Tip You can access table primary key name by Course.Meta.pkname Info For more options visit official sqlalchemy-metadata documentation. Fields Definition To access ormar Fields you can use Model.Meta.model_fields parameter For example to list table model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ({ x : v . __dict__ for x , v in Course . Meta . model_fields . items ()}) \"\"\" Will produce: {'completed': mappingproxy({'autoincrement': False, 'choices': set(), 'column_type': Boolean(), 'default': False, 'index': False, 'name': 'completed', 'nullable': True, 'primary_key': False, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'id': mappingproxy({'autoincrement': True, 'choices': set(), 'column_type': Integer(), 'default': None, 'ge': None, 'index': False, 'le': None, 'maximum': None, 'minimum': None, 'multiple_of': None, 'name': 'id', 'nullable': False, 'primary_key': True, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'name': mappingproxy({'allow_blank': False, 'autoincrement': False, 'choices': set(), 'column_type': String(max_length=100), 'curtail_length': None, 'default': None, 'index': False, 'max_length': 100, 'min_length': None, 'name': 'name', 'nullable': False, 'primary_key': False, 'pydantic_only': False, 'regex': None, 'server_default': None, 'strip_whitespace': False, 'unique': False})} \"\"\" Info Note that fields stored on a model are classes not instances . So if you print just model fields you will get: {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'completed': <class 'ormar.fields.model_fields.Boolean'>}","title":"Models"},{"location":"models/#models","text":"","title":"Models"},{"location":"models/#defining-models","text":"By defining an ormar Model you get corresponding Pydantic model as well as Sqlalchemy table for free. They are being managed in the background and you do not have to create them on your own.","title":"Defining models"},{"location":"models/#model-class","text":"To build an ormar model you simply need to inherit a ormar.Model class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Model Class"},{"location":"models/#defining-fields","text":"Next assign one or more of the Fields as a class level variables.","title":"Defining Fields"},{"location":"models/#basic-field-types","text":"Each table has to have a primary key column, which you specify by setting primary_key=True on selected field. Only one primary key column is allowed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Warning Not assigning primary_key column or assigning more than one column per Model will raise ModelDefinitionError exception. By default if you assign primary key to Integer field, the autoincrement option is set to true. You can disable by passing autoincremant=False . 1 id : int = ormar . Integer ( primary_key = True , autoincrement = False )","title":"Basic Field Types"},{"location":"models/#non-database-fields","text":"Note that if you need a normal pydantic field in your model (used to store value on model or pass around some value) you can define a field with parameter pydantic_only=True . Fields created like this are added to the pydantic model fields -> so are subject to validation according to Field type, also appear in dict() and json() result. The difference is that those fields are not saved in the database . So they won't be included in underlying sqlalchemy columns , or table variables (check Internals section below to see how you can access those if you need). Subsequently pydantic_only fields won't be included in migrations or any database operation (like save , update etc.) Fields like those can be passed around into payload in fastapi request and will be returned in fastapi response (of course only if you set their value somewhere in your code as the value is not fetched from the db. If you pass a value in fastapi request and return the same instance that fastapi constructs for you in request_model you should get back exactly same value in response .). Warning pydantic_only=True fields are always Optional and it cannot be changed (otherwise db load validation would fail) Tip pydantic_only=True fields are a good solution if you need to pass additional information from outside of your API (i.e. frontend). They are not stored in db but you can access them in your APIRoute code and they also have pydantic validation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) non_db_field : str = ormar . String ( max_length = 100 , pydantic_only = True ) If you combine pydantic_only=True field with default parameter and do not pass actual value in request you will always get default value. Since it can be a function you can set default=datetime.datetime.now and get current timestamp each time you call an endpoint etc. Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==part of code removed for clarity==> class User ( ormar . Model ): class Meta : tablename : str = \"users2\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) email : str = ormar . String ( max_length = 255 , nullable = False ) password : str = ormar . String ( max_length = 255 ) first_name : str = ormar . String ( max_length = 255 ) last_name : str = ormar . String ( max_length = 255 ) category : str = ormar . String ( max_length = 255 , nullable = True ) timestamp : datetime . datetime = ormar . DateTime ( pydantic_only = True , default = datetime . datetime . now ) # <==part of code removed for clarity==> app = FastAPI () @app . post ( \"/users/\" ) async def create_user ( user : User ): return await user . save () # <==part of code removed for clarity==> def test_excluding_fields_in_endpoints (): client = TestClient ( app ) with client as client : timestamp = datetime . datetime . now () user = { \"email\" : \"test@domain.com\" , \"password\" : \"^*^%A*DA*IAAA\" , \"first_name\" : \"John\" , \"last_name\" : \"Doe\" , \"timestamp\" : str ( timestamp ), } response = client . post ( \"/users/\" , json = user ) assert list ( response . json () . keys ()) == [ \"id\" , \"email\" , \"first_name\" , \"last_name\" , \"category\" , \"timestamp\" , ] # returned is the same timestamp assert response . json () . get ( \"timestamp\" ) == str ( timestamp ) . replace ( \" \" , \"T\" ) # <==part of code removed for clarity==>","title":"Non Database Fields"},{"location":"models/#property-fields","text":"Sometimes it's desirable to do some kind of calculation on the model instance. One of the most common examples can be concatenating two or more fields. Imagine you have first_name and last_name fields on your model, but would like to have full_name in the result of the fastapi query. You can create a new pydantic model with a method that accepts only self (so like default python @property ) and populate it in your code. But it's so common that ormar has you covered. You can \"materialize\" a property_field on you Model . Warning property_field fields are always Optional and it cannot be changed (otherwise db load validation would fail) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar from ormar import property_field database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) @property_field def prefixed_name ( self ): return 'custom_prefix__' + self . name Warning The decorated function has to accept only one parameter, and that parameter have to be self . If you try to decorate a function with more parameters ormar will raise ModelDefinitionError . Sample: 1 2 3 4 5 6 7 8 9 10 # will raise ModelDefinitionError @property_field def prefixed_name ( self , prefix = \"prefix_\" ): return 'custom_prefix__' + self . name # will raise ModelDefinitionError # (calling first param something else than 'self' is a bad practice anyway) @property_field def prefixed_name ( instance ): return 'custom_prefix__' + self . name Note that property_field decorated methods do not go through verification (but that might change in future) and are only available in the response from fastapi and dict() and json() methods. You cannot pass a value for this field in the request (or rather you can but it will be discarded by ormar so really no point but no Exception will be raised). Note Note that both pydantic_only and property_field decorated field can be included/excluded in both dict() and fastapi response with include / exclude and response_model_include / response_model_exclude accordingly. Tip Note that @property_field decorator is designed to replace the python @property decorator, you do not have to combine them. In theory you can cause ormar have a failsafe mechanism, but note that i.e. mypy will complain about re-decorating a property. 1 2 3 4 5 # valid and working but unnecessary and mypy will complain @property_field @property def prefixed_name ( self ): return 'custom_prefix__' + self . name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # <==part of code removed for clarity==> def gen_pass (): # note: NOT production ready choices = string . ascii_letters + string . digits + \"!@#$%^&*()\" return \"\" . join ( random . choice ( choices ) for _ in range ( 20 )) class RandomModel ( ormar . Model ): class Meta : tablename : str = \"random_users\" metadata = metadata database = database include_props_in_dict = True id : int = ormar . Integer ( primary_key = True ) password : str = ormar . String ( max_length = 255 , default = gen_pass ) first_name : str = ormar . String ( max_length = 255 , default = \"John\" ) last_name : str = ormar . String ( max_length = 255 ) created_date : datetime . datetime = ormar . DateTime ( server_default = sqlalchemy . func . now () ) @property_field def full_name ( self ) -> str : return \" \" . join ([ self . first_name , self . last_name ]) # <==part of code removed for clarity==> app = FastAPI () # explicitly exclude property_field in this endpoint @app . post ( \"/random/\" , response_model = RandomModel , response_model_exclude = { \"full_name\" }) async def create_user ( user : RandomModel ): return await user . save () # <==part of code removed for clarity==> def test_excluding_property_field_in_endpoints2 (): client = TestClient ( app ) with client as client : RandomModel . Meta . include_props_in_dict = True user3 = { \"last_name\" : \"Test\" } response = client . post ( \"/random3/\" , json = user3 ) assert list ( response . json () . keys ()) == [ \"id\" , \"password\" , \"first_name\" , \"last_name\" , \"created_date\" , ] # despite being decorated with property_field if you explictly exclude it it will be gone assert response . json () . get ( \"full_name\" ) is None # <==part of code removed for clarity==>","title":"Property fields"},{"location":"models/#fields-names-vs-column-names","text":"By default names of the fields will be used for both the underlying pydantic model and sqlalchemy table. If for whatever reason you prefer to change the name in the database but keep the name in the model you can do this with specifying name parameter during Field declaration Here you have a sample model with changed names 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Child ( ormar . Model ): class Meta : tablename = \"children\" metadata = metadata database = database id : int = ormar . Integer ( name = \"child_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year_born\" , nullable = True ) Note that you can also change the ForeignKey column name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from typing import Optional import databases import sqlalchemy import ormar from .docs010 import Artist # previous example database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"music_albums\" metadata = metadata database = database id : int = ormar . Integer ( name = \"album_id\" , primary_key = True ) name : str = ormar . String ( name = \"album_name\" , max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist , name = \"artist_id\" ) But for now you cannot change the ManyToMany column names as they go through other Model anyway. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import sqlalchemy import ormar from .docs008 import Child database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () class ArtistChildren ( ormar . Model ): class Meta : tablename = \"children_x_artists\" metadata = metadata database = database class Artist ( ormar . Model ): class Meta : tablename = \"artists\" metadata = metadata database = database id : int = ormar . Integer ( name = \"artist_id\" , primary_key = True ) first_name : str = ormar . String ( name = \"fname\" , max_length = 100 ) last_name : str = ormar . String ( name = \"lname\" , max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) children = ormar . ManyToMany ( Child , through = ArtistChildren )","title":"Fields names vs Column names"},{"location":"models/#type-hints-legacy","text":"Before version 0.4.0 ormar supported only one way of defining Fields on a Model using python type hints as pydantic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () But that didn't play well with static type checkers like mypy and pydantic PyCharm plugin. Therefore from version >=0.4.0 ormar switched to new notation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Note that type hints are optional so perfectly valid ormar code can look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Warning Even if you use type hints ormar does not use them to construct pydantic fields! Type hints are there only to support static checkers and linting, ormar construct annotations used by pydantic from own fields.","title":"Type Hints &amp; Legacy"},{"location":"models/#database-initialization-migrations","text":"Note that all examples assume that you already have a database. If that is not the case and you need to create your tables, that's super easy as ormar is using sqlalchemy for underlying table construction. All you have to do is call create_all() like in the example below. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # note that this has to be the same metadata that is used in ormar Models definition metadata . create_all ( engine ) You can also create single tables, sqlalchemy tables are exposed in ormar.Meta class. 1 2 3 4 5 import sqlalchemy # get your database url in sqlalchemy format - same as used with databases instance used in Model definition engine = sqlalchemy . create_engine ( \"sqlite:///test.db\" ) # Artist is an ormar model from previous examples Artist . Meta . table . create ( engine ) Warning You need to create the tables only once, so use a python console for that or remove the script from your production code after first use. Likewise as with tables, since we base tables on sqlalchemy for migrations please use alembic . Use command line to reproduce this minimalistic example. 1 2 3 alembic init alembic alembic revision -- autogenerate - m \"made some changes\" alembic upgrade head A quick example of alembic migrations should be something similar to: When you have application structure like: 1 2 3 4 5 -> app -> alembic (initialized folder - so run alembic init alembic inside app folder) -> models (here are the models) -> __init__.py -> my_models.py Your env.py file (in alembic folder) can look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from logging.config import fileConfig from sqlalchemy import create_engine from alembic import context import sys , os # add app folder to system path (alternative is running it from parent folder with python -m ...) myPath = os . path . dirname ( os . path . abspath ( __file__ )) sys . path . insert ( 0 , myPath + '/../../' ) # this is the Alembic Config object, which provides # access to the values within the .ini file in use. config = context . config # Interpret the config file for Python logging. # This line sets up loggers basically. fileConfig ( config . config_file_name ) # add your model's MetaData object here (the one used in ormar) # for 'autogenerate' support from app.models.my_models import metadata target_metadata = metadata # set your url here or import from settings # note that by default url is in saved sqlachemy.url variable in alembic.ini file URL = \"sqlite:///test.db\" def run_migrations_offline (): \"\"\"Run migrations in 'offline' mode. This configures the context with just a URL and not an Engine, though an Engine is acceptable here as well. By skipping the Engine creation we don't even need a DBAPI to be available. Calls to context.execute() here emit the given string to the script output. \"\"\" context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () def run_migrations_online (): \"\"\"Run migrations in 'online' mode. In this scenario we need to create an Engine and associate a connection with the context. \"\"\" connectable = create_engine ( URL ) with connectable . connect () as connection : context . configure ( connection = connection , target_metadata = target_metadata , # if you use UUID field set also this param # the prefix has to match sqlalchemy import name in alembic # that can be set by sqlalchemy_module_prefix option (default 'sa.') user_module_prefix = 'sa.' ) with context . begin_transaction (): context . run_migrations () if context . is_offline_mode (): run_migrations_offline () else : run_migrations_online () You can also include/exclude specific tables with include_object parameter passed to context.configure . That should be a function returning True/False for given objects. A sample function excluding tables starting with data_ in name unless it's 'data_jobs': 1 2 3 4 5 def include_object ( object , name , type_ , reflected , compare_to ): if name and name . startswith ( 'data_' ) and name not in [ 'data_jobs' ]: return False return True Note Function parameters for include_objects (you can change the name) are required and defined in alembic to check what they do check the alembic documentation And you pass it into context like (both in online and offline): 1 2 3 4 5 6 7 8 context . configure ( url = URL , target_metadata = target_metadata , literal_binds = True , dialect_opts = { \"paramstyle\" : \"named\" }, user_module_prefix = 'sa.' , include_object = include_object ) Info You can read more about table creation, altering and migrations in sqlalchemy table creation documentation.","title":"Database initialization/ migrations"},{"location":"models/#dependencies","text":"Since ormar depends on databases and sqlalchemy-core for database connection and table creation you need to assign each Model with two special parameters.","title":"Dependencies"},{"location":"models/#databases","text":"One is Database instance created with your database url in sqlalchemy connection string format. Created instance needs to be passed to every Model with Meta class database parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the Database instance only once and use it for all models. You can create several ones if you want to use multiple databases.","title":"Databases"},{"location":"models/#sqlalchemy","text":"Second dependency is sqlalchemy MetaData instance. Created instance needs to be passed to every Model with Meta class metadata parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) Tip You need to create the MetaData instance only once and use it for all models. You can create several ones if you want to use multiple databases.","title":"Sqlalchemy"},{"location":"models/#best-practice","text":"Only thing that ormar expects is a class with name Meta and two class variables: metadata and databases . So instead of providing the same parameters over and over again for all models you should creata a class and subclass it in all models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///test.db\" , force_rollback = True ) metadata = sqlalchemy . MetaData () # note that you do not have to subclass ModelMeta, # it's useful for type hints and code completion class MainMeta ( ormar . ModelMeta ): metadata = metadata database = database class Artist ( ormar . Model ): class Meta ( MainMeta ): # note that tablename is optional # if not provided ormar will user class.__name__.lower()+'s' # -> artists in this example pass id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 100 ) last_name : str = ormar . String ( max_length = 100 ) born_year : int = ormar . Integer ( name = \"year\" ) class Album ( ormar . Model ): class Meta ( MainMeta ): pass id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) artist : Optional [ Artist ] = ormar . ForeignKey ( Artist ) Warning You need to subclass your MainMeta class in each Model class as those classes store configuration variables that otherwise would be overwritten by each Model .","title":"Best practice"},{"location":"models/#table-names","text":"By default table name is created from Model class name as lowercase name plus 's'. You can overwrite this parameter by providing Meta class tablename argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : # if you omit this parameter it will be created automatically # as class.__name__.lower()+'s' -> \"courses\" in this example tablename = \"my_courses\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Table Names"},{"location":"models/#constraints","text":"On a model level you can also set model-wise constraints on sql columns. Right now only UniqueColumns constraint is present. Tip To read more about columns constraints like primary_key , unique , ForeignKey etc. visit fields . You can set this parameter by providing Meta class constraints argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata # define your constraints in Meta class of the model # it's a list that can contain multiple constraints # hera a combination of name and column will have to be unique in db constraints = [ ormar . UniqueColumns ( \"name\" , \"completed\" )] id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Constraints"},{"location":"models/#model-initialization","text":"There are two ways to create and persist the Model instance in the database. Tip Use ipython to try this from the console, since it supports await . If you plan to modify the instance in the later execution of your program you can initiate your Model as a normal class and later await a save() call. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) If you want to initiate your Model and at the same time save in in the database use a QuerySet's method create() . For creating multiple objects at once a bulk_create() QuerySet's method is available. Each model has a QuerySet initialised as objects parameter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) course = Course ( name = \"Painting for dummies\" , completed = False ) await course . save () await Course . objects . create ( name = \"Painting for dummies\" , completed = False ) Info To read more about QuerySets (including bulk operations) and available methods visit queries","title":"Model Initialization"},{"location":"models/#model-save-status","text":"Each model instance is a separate python object and they do not know anything about each other. 1 2 3 4 5 6 7 8 track1 = await Track . objects . get ( name = 'The Bird' ) track2 = await Track . objects . get ( name = 'The Bird' ) assert track1 == track2 # True track1 . name = 'The Bird2' await track1 . save () assert track1 . name == track2 . name # False # track2 does not update and knows nothing about track1 The objects itself have a saved status, which is set as following: Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantiation with __init__ (w/o QuerySet.create or before calling save ) You can check if model is saved with ModelInstance.saved property","title":"Model save status"},{"location":"models/#model-methods","text":"","title":"Model methods"},{"location":"models/#load","text":"By default when you query a table without prefetching related models, the ormar will still construct your related models, but populate them only with the pk value. You can load the related model by calling load() method. load() can also be used to refresh the model from the database (if it was changed by some other process). 1 2 3 4 5 6 7 track = await Track . objects . get ( name = 'The Bird' ) track . album . pk # will return malibu album pk (1) track . album . name # will return None # you need to actually load the data first await track . album . load () track . album . name # will return 'Malibu'","title":"load"},{"location":"models/#save","text":"save() -> self You can create new models by using QuerySet.create() method or by initializing your model as a normal pydantic model and later calling save() method. save() can also be used to persist changes that you made to the model, but only if the primary key is not set or the model does not exist in database. The save() method does not check if the model exists in db, so if it does you will get a integrity error from your selected db backend if trying to save model with already existing primary key. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . save () # will persist the model in database track = await Track . objects . get ( name = 'The Bird' ) await track . save () # will raise integrity error as pk is populated","title":"save"},{"location":"models/#update","text":"update(**kwargs) -> self You can update models by using QuerySet.update() method or by updating your model attributes (fields) and calling update() method. If you try to update a model without a primary key set a ModelPersistenceError exception will be thrown. To persist a newly created model use save() or upsert(**kwargs) methods. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . update ( name = 'The Bird Strikes Again' )","title":"update"},{"location":"models/#upsert","text":"upsert(**kwargs) -> self It's an proxy to either save() or update(**kwargs) methods described above. If the primary key is set -> the update method will be called. If the pk is not set the save() method will be called. 1 2 3 4 5 track = Track ( name = 'The Bird' ) await track . upsert () # will call save as the pk is empty track = await Track . objects . get ( name = 'The Bird' ) await track . upsert ( name = 'The Bird Strikes Again' ) # will call update as pk is already populated","title":"upsert"},{"location":"models/#delete","text":"You can delete models by using QuerySet.delete() method or by using your model and calling delete() method. 1 2 track = await Track . objects . get ( name = 'The Bird' ) await track . delete () # will delete the model from database Tip Note that that track object stays the same, only record in the database is removed.","title":"delete"},{"location":"models/#save_related","text":"save_related(follow: bool = False) -> None Method goes through all relations of the Model on which the method is called, and calls upsert() method on each model that is not saved. To understand when a model is saved check save status section above. By default the save_related method saved only models that are directly related (one step away) to the model on which the method is called. But you can specify the follow=True parameter to traverse through nested models and save all of them in the relation tree. Warning To avoid circular updates with follow=True set, save_related keeps a set of already visited Models, and won't perform nested save_related on Models that were already visited. So if you have a diamond or circular relations types you need to perform the updates in a manual way. 1 2 # in example like this the second Street (coming from City) won't be save_related, so ZipCode won't be updated Street -> District -> City -> Street -> ZipCode","title":"save_related"},{"location":"models/#internals","text":"Apart from special parameters defined in the Model during definition (tablename, metadata etc.) the Model provides you with useful internals.","title":"Internals"},{"location":"models/#pydantic-model","text":"All Model classes inherit from pydantic.BaseModel so you can access all normal attributes of pydantic models. For example to list pydantic model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . __fields__ ) \"\"\" Will produce: {'id': ModelField(name='id', type=Optional[int], required=False, default=None), 'name': ModelField(name='name', type=Optional[str], required=False, default=None), 'completed': ModelField(name='completed', type=bool, required=False, default=False)} \"\"\" Tip Note how the primary key id field is optional as Integer primary key by default has autoincrement set to True . Info For more options visit official pydantic documentation.","title":"Pydantic Model"},{"location":"models/#sqlalchemy-table","text":"To access auto created sqlalchemy table you can use Model.Meta.table parameter For example to list table columns you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): # note you don't have to subclass - but it's recommended for ide completion and mypy database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ( Course . Meta . table . columns ) \"\"\" Will produce: ['courses.id', 'courses.name', 'courses.completed'] \"\"\" Tip You can access table primary key name by Course.Meta.pkname Info For more options visit official sqlalchemy-metadata documentation.","title":"Sqlalchemy Table"},{"location":"models/#fields-definition","text":"To access ormar Fields you can use Model.Meta.model_fields parameter For example to list table model fields you can: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta ( ormar . ModelMeta ): database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) print ({ x : v . __dict__ for x , v in Course . Meta . model_fields . items ()}) \"\"\" Will produce: {'completed': mappingproxy({'autoincrement': False, 'choices': set(), 'column_type': Boolean(), 'default': False, 'index': False, 'name': 'completed', 'nullable': True, 'primary_key': False, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'id': mappingproxy({'autoincrement': True, 'choices': set(), 'column_type': Integer(), 'default': None, 'ge': None, 'index': False, 'le': None, 'maximum': None, 'minimum': None, 'multiple_of': None, 'name': 'id', 'nullable': False, 'primary_key': True, 'pydantic_only': False, 'server_default': None, 'unique': False}), 'name': mappingproxy({'allow_blank': False, 'autoincrement': False, 'choices': set(), 'column_type': String(max_length=100), 'curtail_length': None, 'default': None, 'index': False, 'max_length': 100, 'min_length': None, 'name': 'name', 'nullable': False, 'primary_key': False, 'pydantic_only': False, 'regex': None, 'server_default': None, 'strip_whitespace': False, 'unique': False})} \"\"\" Info Note that fields stored on a model are classes not instances . So if you print just model fields you will get: {'id': <class 'ormar.fields.model_fields.Integer'>, 'name': <class 'ormar.fields.model_fields.String'>, 'completed': <class 'ormar.fields.model_fields.Boolean'>}","title":"Fields Definition"},{"location":"mypy/","text":"To provide better errors check you should use mypy with pydantic plugin Note that legacy model declaration type will raise static type analyzers errors. So you cannot use the old notation like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : ormar . Integer ( primary_key = True ) name : ormar . String ( max_length = 100 ) completed : ormar . Boolean ( default = False ) c1 = Course () Instead switch to notation introduced in version 0.4.0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id = ormar . Integer ( primary_key = True ) name = ormar . String ( max_length = 100 ) completed = ormar . Boolean ( default = False ) Note that above example is not using the type hints, so further operations with mypy might fail, depending on the context. Preferred notation should look liked this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False )","title":"Use with mypy"},{"location":"plugin/","text":"While ormar will work with any IDE there is a PyCharm pydantic plugin that enhances the user experience for this IDE. Plugin is available on the JetBrains Plugins Repository for PyCharm: plugin page . You can install the plugin for free from the plugin marketplace (PyCharm's Preferences -> Plugin -> Marketplace -> search \"pydantic\"). Note For plugin to work properly you need to provide valid type hints for model fields. Info Plugin supports type hints, argument inspection and more but mainly only for init methods More information can be found on the official plugin page and github repository .","title":"PyCharm plugin"},{"location":"queries/","text":"Queries QuerySet Each Model is auto registered with a QuerySet that represents the underlaying query and it's options. Most of the methods are also available through many to many relation interface. Info To see which one are supported and how to construct relations visit relations . Given the Models like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import Optional import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () we can demonstrate available methods to fetch and save the data into the database. create create(**kwargs): -> Model Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. 1 2 malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) The alternative is a split creation and persistence of the Model . 1 2 malibu = Album ( name = \"Malibu\" ) await malibu . save () Tip Check other Model methods in models get get(**kwargs): -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the first row in db. Passing a criteria is actually calling filter(**kwargs) method described below. 1 2 3 4 track = await Track . objects . get ( name = 'The Bird' ) # note that above is equivalent to await Track.objects.filter(name='The Bird').get() track2 = track = await Track . objects . get () track == track2 # True since it's the only row in db in our example Warning If no row meets the criteria NoMatch exception is raised. If there are multiple rows meeting the criteria the MultipleMatches exception is raised. get_or_create get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being a equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement update update(each: bool = False, **kwargs) -> int QuerySet level update is used to update multiple records with the same value at once. You either have to filter the QuerySet first or provide a each=True flag to update whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows updated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . update ( each = True , genre = 'Fiction' ) all_books = await Book . objects . filter ( genre = 'Fiction' ) . all () assert len ( all_books ) == 3 Warning Queryset needs to be filtered before updating to prevent accidental overwrite. To update whole database table each=True needs to be provided as a safety switch update_or_create update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement bulk_create bulk_create(objects: List[\"Model\"]) -> None Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class ToDo ( ormar . Model ): class Meta : tablename = \"todos\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) text : str = ormar . String ( max_length = 500 ) completed = ormar . Boolean ( default = False ) # create multiple instances at once with bulk_create await ToDo . objects . bulk_create ( [ ToDo ( text = \"Buy the groceries.\" ), ToDo ( text = \"Call Mum.\" , completed = True ), ToDo ( text = \"Send invoices.\" , completed = True ), ] ) todoes = await ToDo . objects . all () assert len ( todoes ) == 3 bulk_update bulk_update(objects: List[\"Model\"], columns: List[str] = None) -> None Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. 1 2 3 4 5 6 7 8 9 10 11 # continuing the example from bulk_create # update objects for todo in todoes : todo . completed = False # perform update of all objects at once # objects need to have pk column set, otherwise exception is raised await ToDo . objects . bulk_update ( todoes ) completed = await ToDo . objects . filter ( completed = False ) . all () assert len ( completed ) == 3 delete delete(each: bool = False, **kwargs) -> int QuerySet level delete is used to delete multiple records at once. You either have to filter the QuerySet first or provide a each=True flag to delete whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows deleted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace in Space' , author = \"Tolstoy, Leo\" , genre = 'Fantasy' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # delete accepts kwargs that will be used in filter # acting in same way as queryset.filter(**kwargs).delete() await Book . objects . delete ( genre = 'Fantasy' ) # delete all fantasy books all_books = await Book . objects . all () assert len ( all_books ) == 2 all all(**kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. 1 2 3 4 5 tracks = await Track . objects . select_related ( \"album\" ) . all ( title = 'Sample' ) # will return a list of all Tracks with title Sample tracks = await Track . objects . all () # will return a list of all Tracks in database filter filter(**kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. 1 2 3 4 5 track = Track . objects . filter ( name = \"The Bird\" ) . get () # will return a track with name equal to 'The Bird' tracks = Track . objects . filter ( album__name = \"Fantasies\" ) . all () # will return all tracks where the columns album name = 'Fantasies' You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (exact start match case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (exact end match case insensitive) Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() exclude exclude(**kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which equals to where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) 1 2 notes = await Track . objects . exclude ( position_gt = 3 ) . all () # returns all tracks with position < 3 select_related select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Note If you are coming from django note that ormar select_related differs -> in django you can select_related only singe relation types, while in ormar you can select related across ForeignKey relation, reverse side of ForeignKey (so virtual auto generated keys) and ManyToMany fields (so all relations as of current version). Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 album = await Album . objects . select_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string or a list of strings 1 2 3 4 classes = await SchoolClass . objects . select_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() prefetch_related prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 album = await Album . objects . prefetch_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string or a list of strings 1 2 3 4 classes = await SchoolClass . objects . prefetch_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() select_related vs prefetch_related Which should you use -> select_related or prefetch_related ? Well, it really depends on your data. The best answer is try yourself and see which one performs faster/better in your system constraints. What to keep in mind: Performance Number of queries : select_related always executes one query against the database, while prefetch_related executes multiple queries. Usually the query (I/O) operation is the slowest one but it does not have to be. Number of rows : Imagine that you have 10 000 object in one table A and each of those objects have 3 children in table B, and subsequently each object in table B has 2 children in table C. Something like this: 1 2 3 4 5 6 7 8 9 10 11 Model C / Model B - Model C / Model A - Model B - Model C \\ \\ \\ Model C \\ Model B - Model C \\ Model C That means that select_related will always return 60 000 rows (10 000 * 3 * 2) later compacted to 10 000 models. How many rows will return prefetch_related ? Well, that depends, if each of models B and C is unique it will return 10 000 rows in first query, 30 000 rows (each of 3 children of A in table B are unique) in second query and 60 000 rows (each of 2 children of model B in table C are unique) in 3rd query. In this case select_related seems like a better choice, not only it will run one query comparing to 3 of prefetch_related but will also return 60 000 rows comparing to 100 000 of prefetch_related (10+30+60k). But what if each Model A has exactly the same 3 models B and each models C has exactly same models C? select_related will still return 60 000 rows, while prefetch_related will return 10 000 for model A, 3 rows for model B and 2 rows for Model C. So in total 10 006 rows. Now depending on the structure of models (i.e. if it has long Text() fields etc.) prefetch_related might be faster despite it needs to perform three separate queries instead of one. Memory ormar is a mini ORM meaning that it does not keep a registry of already loaded models. That means that in select_related example above you will always have 10 000 Models A, 30 000 Models B (even if the unique number of rows in db is 3 - processing of select_related spawns new child models for each parent model). And 60 000 Models C. If the same Model B is shared by rows 1, 10, 100 etc. and you update one of those, the rest of rows that share the same child will not be updated on the spot. If you persist your changes into the database the change will be available only after reload (either each child separately or the whole query again) . That means that select_related will use more memory as each child is instantiated as a new object - obviously using it's own space. Note This might change in future versions if we decide to introduce caching. Warning By default all children (or event the same models loaded 2+ times) are completely independent, distinct python objects, despite that they represent the same row in db. They will evaluate to True when compared, so in example above: 1 2 3 4 5 6 7 8 # will return True if child1 of both rows is the same child db row row1 . child1 == row100 . child1 # same here: model1 = await Model . get ( pk = 1 ) model2 = await Model . get ( pk = 1 ) # same pk = same row in db # will return `True` model1 == model2 but 1 2 3 4 5 # will return False (note that id is a python `builtin` function not ormar one). id ( row1 . child1 ) == ( ro100 . child1 ) # from above - will also return False id ( model1 ) == id ( model2 ) On the contrary - with prefetch_related each unique distinct child model is instantiated only once and the same child models is shared across all parent models. That means that in prefetch_related example above if there are 3 distinct models in table B and 2 in table C, there will be only 5 children nested models shared between all model A instances. That also means that if you update any attribute it will be updated on all parents as they share the same child object. limit limit(limit_count: int) -> QuerySet You can limit the results to desired number of rows. 1 2 tracks = await Track . objects . limit ( 1 ) . all () # will return just one Track Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() offset offset(offset: int) -> QuerySet You can also offset the results by desired number of rows. 1 2 tracks = await Track . objects . offset ( 1 ) . limit ( 1 ) . all () # will return just one Track, but this time the second one Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() count count() -> int Returns number of rows matching the given criteria (applied with filter and exclude ) 1 2 # returns count of rows in db no_of_books = await Book . objects . count () exists exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude ) 1 2 # returns a boolean value if given row exists has_sample = await Book . objects . filter ( title = 'Sample' ) . exists () fields fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Given a sample data like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . 1 2 3 4 5 6 7 8 9 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. 1 2 3 4 5 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ( 'id' ) . fields ( [ 'name' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. You cannot exclude mandatory model columns - manufacturer__name in this example. 1 2 await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__founded' ]) . all () # will raise pydantic ValidationError as company.name is required Tip Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Below you can see examples that are equivalent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. like in example above await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () # 2. to mark a field as required use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' : ... } }) . all () # 3. to include whole nested model use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : ... }) . all () # 4. to specify fields at last nesting level you can also use set - equivalent to 2. above await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' } }) . all () # 5. of course set can have multiple fields await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' , 'founded' } }) . all () # 6. you can include all nested fields but it will be equivalent of 3. above which is shorter await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'id' , 'name' , 'founded' } }) . all () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() exclude_fields exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Below you can find few simple examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) # select manufacturer but only name - to include related models use notation {model_name}__{column} all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' , 'company__founded' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None # fields() can be called several times, building up the columns to select # models selected in select_related but with no columns in fields list implies all fields all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( 'year' ) . exclude_fields ( [ 'gear' , 'gearbox_type' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 # cannot exclude mandatory model columns - company__name in this example - note usage of dict/set this time await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ([{ 'company' : { 'name' }}]) . all () # will raise pydantic ValidationError as company.name is required Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Tip Pk column cannot be excluded - it's always auto added even if explicitly excluded. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all() order_by order_by(columns: Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with different fields. Ordering in sql will be applied in order of names you provide in order_by. Tip By default if you do not provide ordering ormar explicitly orders by all primary keys Warning If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. Sample raw database rows result (sort by child model desc): 1 2 3 MODEL: 1 - Child Model - 3 MODEL: 2 - Child Model - 2 MODEL: 1 - Child Model - 1 will result in 2 rows of result: 1 2 MODEL: 1 - Child Models: [3, 1] # encountered first in result, all children rows combined MODEL: 2 - Child Modles: [2] The main model will never duplicate in the result Given sample Models like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Owner ( ormar . Model ): class Meta : tablename = \"owners\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Toy ( ormar . Model ): class Meta : tablename = \"toys\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) owner : Owner = ormar . ForeignKey ( Owner ) # build some sample data aphrodite = await Owner . objects . create ( name = \"Aphrodite\" ) hermes = await Owner . objects . create ( name = \"Hermes\" ) zeus = await Owner . objects . create ( name = \"Zeus\" ) await Toy . objects . create ( name = \"Toy 4\" , owner = zeus ) await Toy . objects . create ( name = \"Toy 5\" , owner = hermes ) await Toy . objects . create ( name = \"Toy 2\" , owner = aphrodite ) await Toy . objects . create ( name = \"Toy 1\" , owner = zeus ) await Toy . objects . create ( name = \"Toy 3\" , owner = aphrodite ) await Toy . objects . create ( name = \"Toy 6\" , owner = hermes ) To order by main model field just provide a field name 1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"name\" ) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. 1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"owner__name\" ) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\" To sort in descending order provide a hyphen in front of the field name 1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( \"-toys__name\" ) . filter ( name = \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\" Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"Queries"},{"location":"queries/#queries","text":"","title":"Queries"},{"location":"queries/#queryset","text":"Each Model is auto registered with a QuerySet that represents the underlaying query and it's options. Most of the methods are also available through many to many relation interface. Info To see which one are supported and how to construct relations visit relations . Given the Models like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from typing import Optional import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"album\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Track ( ormar . Model ): class Meta : tablename = \"track\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) album : Optional [ Album ] = ormar . ForeignKey ( Album ) title : str = ormar . String ( max_length = 100 ) position : int = ormar . Integer () we can demonstrate available methods to fetch and save the data into the database.","title":"QuerySet"},{"location":"queries/#create","text":"create(**kwargs): -> Model Creates the model instance, saves it in a database and returns the updates model (with pk populated if not passed and autoincrement is set). The allowed kwargs are Model fields names and proper value types. 1 2 malibu = await Album . objects . create ( name = \"Malibu\" ) await Track . objects . create ( album = malibu , title = \"The Bird\" , position = 1 ) The alternative is a split creation and persistence of the Model . 1 2 malibu = Album ( name = \"Malibu\" ) await malibu . save () Tip Check other Model methods in models","title":"create"},{"location":"queries/#get","text":"get(**kwargs): -> Model Get's the first row from the db meeting the criteria set by kwargs. If no criteria set it will return the first row in db. Passing a criteria is actually calling filter(**kwargs) method described below. 1 2 3 4 track = await Track . objects . get ( name = 'The Bird' ) # note that above is equivalent to await Track.objects.filter(name='The Bird').get() track2 = track = await Track . objects . get () track == track2 # True since it's the only row in db in our example Warning If no row meets the criteria NoMatch exception is raised. If there are multiple rows meeting the criteria the MultipleMatches exception is raised.","title":"get"},{"location":"queries/#get_or_create","text":"get_or_create(**kwargs) -> Model Combination of create and get methods. Tries to get a row meeting the criteria and if NoMatch exception is raised it creates a new one with given kwargs. 1 2 3 4 5 album = await Album . objects . get_or_create ( name = 'The Cat' ) # object is created as it does not exist album2 = await Album . objects . get_or_create ( name = 'The Cat' ) assert album == album2 # return True as the same db row is returned Warning Despite being a equivalent row from database the album and album2 in example above are 2 different python objects! Updating one of them will not refresh the second one until you excplicitly load() the fresh data from db. Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"get_or_create"},{"location":"queries/#update","text":"update(each: bool = False, **kwargs) -> int QuerySet level update is used to update multiple records with the same value at once. You either have to filter the QuerySet first or provide a each=True flag to update whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows updated. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . update ( each = True , genre = 'Fiction' ) all_books = await Book . objects . filter ( genre = 'Fiction' ) . all () assert len ( all_books ) == 3 Warning Queryset needs to be filtered before updating to prevent accidental overwrite. To update whole database table each=True needs to be provided as a safety switch","title":"update"},{"location":"queries/#update_or_create","text":"update_or_create(**kwargs) -> Model Updates the model, or in case there is no match in database creates a new one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # if not exist the instance will be persisted in db vol2 = await Book . objects . update_or_create ( title = \"Volume II\" , author = 'Anonymous' , genre = 'Fiction' ) assert await Book . objects . count () == 1 # if pk or pkname passed in kwargs (like id here) the object will be updated assert await Book . objects . update_or_create ( id = vol2 . id , genre = 'Historic' ) assert await Book . objects . count () == 1 Note Note that if you want to create a new object you either have to pass pk column value or pk column has to be set as autoincrement","title":"update_or_create"},{"location":"queries/#bulk_create","text":"bulk_create(objects: List[\"Model\"]) -> None Allows you to create multiple objects at once. A valid list of Model objects needs to be passed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class ToDo ( ormar . Model ): class Meta : tablename = \"todos\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) text : str = ormar . String ( max_length = 500 ) completed = ormar . Boolean ( default = False ) # create multiple instances at once with bulk_create await ToDo . objects . bulk_create ( [ ToDo ( text = \"Buy the groceries.\" ), ToDo ( text = \"Call Mum.\" , completed = True ), ToDo ( text = \"Send invoices.\" , completed = True ), ] ) todoes = await ToDo . objects . all () assert len ( todoes ) == 3","title":"bulk_create"},{"location":"queries/#bulk_update","text":"bulk_update(objects: List[\"Model\"], columns: List[str] = None) -> None Allows to update multiple instance at once. All Models passed need to have primary key column populated. You can also select which fields to update by passing columns list as a list of string names. 1 2 3 4 5 6 7 8 9 10 11 # continuing the example from bulk_create # update objects for todo in todoes : todo . completed = False # perform update of all objects at once # objects need to have pk column set, otherwise exception is raised await ToDo . objects . bulk_update ( todoes ) completed = await ToDo . objects . filter ( completed = False ) . all () assert len ( completed ) == 3","title":"bulk_update"},{"location":"queries/#delete","text":"delete(each: bool = False, **kwargs) -> int QuerySet level delete is used to delete multiple records at once. You either have to filter the QuerySet first or provide a each=True flag to delete whole table. If you do not provide this flag or a filter a QueryDefinitionError will be raised. Return number of rows deleted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Book ( ormar . Model ): class Meta : tablename = \"books\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) author : str = ormar . String ( max_length = 100 ) genre : str = ormar . String ( max_length = 100 , default = 'Fiction' , choices = [ 'Fiction' , 'Adventure' , 'Historic' , 'Fantasy' ]) await Book . objects . create ( title = 'Tom Sawyer' , author = \"Twain, Mark\" , genre = 'Adventure' ) await Book . objects . create ( title = 'War and Peace in Space' , author = \"Tolstoy, Leo\" , genre = 'Fantasy' ) await Book . objects . create ( title = 'Anna Karenina' , author = \"Tolstoy, Leo\" , genre = 'Fiction' ) # delete accepts kwargs that will be used in filter # acting in same way as queryset.filter(**kwargs).delete() await Book . objects . delete ( genre = 'Fantasy' ) # delete all fantasy books all_books = await Book . objects . all () assert len ( all_books ) == 2","title":"delete"},{"location":"queries/#all","text":"all(**kwargs) -> List[Optional[\"Model\"]] Returns all rows from a database for given model for set filter options. Passing kwargs is a shortcut and equals to calling filter(**kwrags).all() . If there are no rows meeting the criteria an empty list is returned. 1 2 3 4 5 tracks = await Track . objects . select_related ( \"album\" ) . all ( title = 'Sample' ) # will return a list of all Tracks with title Sample tracks = await Track . objects . all () # will return a list of all Tracks in database","title":"all"},{"location":"queries/#filter","text":"filter(**kwargs) -> QuerySet Allows you to filter by any Model attribute/field as well as to fetch instances, with a filter across an FK relationship. 1 2 3 4 5 track = Track . objects . filter ( name = \"The Bird\" ) . get () # will return a track with name equal to 'The Bird' tracks = Track . objects . filter ( album__name = \"Fantasies\" ) . all () # will return all tracks where the columns album name = 'Fantasies' You can use special filter suffix to change the filter operands: exact - like album__name__exact='Malibu' (exact match) iexact - like album__name__iexact='malibu' (exact match case insensitive) contains - like album__name__contains='Mal' (sql like) icontains - like album__name__icontains='mal' (sql like case insensitive) in - like album__name__in=['Malibu', 'Barclay'] (sql in) gt - like position__gt=3 (sql >) gte - like position__gte=3 (sql >=) lt - like position__lt=3 (sql <) lte - like position__lte=3 (sql <=) startswith - like album__name__startswith='Mal' (exact start match) istartswith - like album__name__istartswith='mal' (exact start match case insensitive) endswith - like album__name__endswith='ibu' (exact end match) iendswith - like album__name__iendswith='IBU' (exact end match case insensitive) Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"filter"},{"location":"queries/#exclude","text":"exclude(**kwargs) -> QuerySet Works exactly the same as filter and all modifiers (suffixes) are the same, but returns a not condition. So if you use filter(name='John') which equals to where name = 'John' in SQL, the exclude(name='John') equals to where name <> 'John' Note that all conditions are joined so if you pass multiple values it becomes a union of conditions. exclude(name='John', age>=35) will become where not (name='John' and age>=35) 1 2 notes = await Track . objects . exclude ( position_gt = 3 ) . all () # returns all tracks with position < 3","title":"exclude"},{"location":"queries/#select_related","text":"select_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during the same query. With select_related always only one query is run against the database , meaning that one (sometimes complicated) join is generated and later nested models are processed in python. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Note If you are coming from django note that ormar select_related differs -> in django you can select_related only singe relation types, while in ormar you can select related across ForeignKey relation, reverse side of ForeignKey (so virtual auto generated keys) and ManyToMany fields (so all relations as of current version). Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 album = await Album . objects . select_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string or a list of strings 1 2 3 4 classes = await SchoolClass . objects . select_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"select_related"},{"location":"queries/#prefetch_related","text":"prefetch_related(related: Union[List, str]) -> QuerySet Allows to prefetch related models during query - but opposite to select_related each subsequent model is fetched in a separate database query. With prefetch_related always one query per Model is run against the database , meaning that you will have multiple queries executed one after another. To fetch related model use ForeignKey names. To chain related Models relation use double underscores between names. Tip To control which model fields to select use fields() and exclude_fields() QuerySet methods. Tip To control order of models (both main or nested) use order_by() method. 1 2 album = await Album . objects . prefetch_related ( \"tracks\" ) . all () # will return album will all columns tracks You can provide a string or a list of strings 1 2 3 4 classes = await SchoolClass . objects . prefetch_related ( [ \"teachers__category\" , \"students\" ]) . all () # will return classes with teachers and teachers categories # as well as classes students Exactly the same behavior is for Many2Many fields, where you put the names of Many2Many fields and the final Models are fetched for you. Warning If you set ForeignKey field as not nullable (so required) during all queries the not nullable Models will be auto prefetched, even if you do not include them in select_related. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"prefetch_related"},{"location":"queries/#select_related-vs-prefetch_related","text":"Which should you use -> select_related or prefetch_related ? Well, it really depends on your data. The best answer is try yourself and see which one performs faster/better in your system constraints. What to keep in mind:","title":"select_related vs prefetch_related"},{"location":"queries/#performance","text":"Number of queries : select_related always executes one query against the database, while prefetch_related executes multiple queries. Usually the query (I/O) operation is the slowest one but it does not have to be. Number of rows : Imagine that you have 10 000 object in one table A and each of those objects have 3 children in table B, and subsequently each object in table B has 2 children in table C. Something like this: 1 2 3 4 5 6 7 8 9 10 11 Model C / Model B - Model C / Model A - Model B - Model C \\ \\ \\ Model C \\ Model B - Model C \\ Model C That means that select_related will always return 60 000 rows (10 000 * 3 * 2) later compacted to 10 000 models. How many rows will return prefetch_related ? Well, that depends, if each of models B and C is unique it will return 10 000 rows in first query, 30 000 rows (each of 3 children of A in table B are unique) in second query and 60 000 rows (each of 2 children of model B in table C are unique) in 3rd query. In this case select_related seems like a better choice, not only it will run one query comparing to 3 of prefetch_related but will also return 60 000 rows comparing to 100 000 of prefetch_related (10+30+60k). But what if each Model A has exactly the same 3 models B and each models C has exactly same models C? select_related will still return 60 000 rows, while prefetch_related will return 10 000 for model A, 3 rows for model B and 2 rows for Model C. So in total 10 006 rows. Now depending on the structure of models (i.e. if it has long Text() fields etc.) prefetch_related might be faster despite it needs to perform three separate queries instead of one.","title":"Performance"},{"location":"queries/#memory","text":"ormar is a mini ORM meaning that it does not keep a registry of already loaded models. That means that in select_related example above you will always have 10 000 Models A, 30 000 Models B (even if the unique number of rows in db is 3 - processing of select_related spawns new child models for each parent model). And 60 000 Models C. If the same Model B is shared by rows 1, 10, 100 etc. and you update one of those, the rest of rows that share the same child will not be updated on the spot. If you persist your changes into the database the change will be available only after reload (either each child separately or the whole query again) . That means that select_related will use more memory as each child is instantiated as a new object - obviously using it's own space. Note This might change in future versions if we decide to introduce caching. Warning By default all children (or event the same models loaded 2+ times) are completely independent, distinct python objects, despite that they represent the same row in db. They will evaluate to True when compared, so in example above: 1 2 3 4 5 6 7 8 # will return True if child1 of both rows is the same child db row row1 . child1 == row100 . child1 # same here: model1 = await Model . get ( pk = 1 ) model2 = await Model . get ( pk = 1 ) # same pk = same row in db # will return `True` model1 == model2 but 1 2 3 4 5 # will return False (note that id is a python `builtin` function not ormar one). id ( row1 . child1 ) == ( ro100 . child1 ) # from above - will also return False id ( model1 ) == id ( model2 ) On the contrary - with prefetch_related each unique distinct child model is instantiated only once and the same child models is shared across all parent models. That means that in prefetch_related example above if there are 3 distinct models in table B and 2 in table C, there will be only 5 children nested models shared between all model A instances. That also means that if you update any attribute it will be updated on all parents as they share the same child object.","title":"Memory"},{"location":"queries/#limit","text":"limit(limit_count: int) -> QuerySet You can limit the results to desired number of rows. 1 2 tracks = await Track . objects . limit ( 1 ) . all () # will return just one Track Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"limit"},{"location":"queries/#offset","text":"offset(offset: int) -> QuerySet You can also offset the results by desired number of rows. 1 2 tracks = await Track . objects . offset ( 1 ) . limit ( 1 ) . all () # will return just one Track, but this time the second one Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"offset"},{"location":"queries/#count","text":"count() -> int Returns number of rows matching the given criteria (applied with filter and exclude ) 1 2 # returns count of rows in db no_of_books = await Book . objects . count ()","title":"count"},{"location":"queries/#exists","text":"exists() -> bool Returns a bool value to confirm if there are rows matching the given criteria (applied with filter and exclude ) 1 2 # returns a boolean value if given row exists has_sample = await Book . objects . filter ( title = 'Sample' ) . exists ()","title":"exists"},{"location":"queries/#fields","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet With fields() you can select subset of model columns to limit the data load. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Given a sample data like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) You can select specified fields by passing a str, List[str], Set[str] or dict with nested definition. To include related models use notation {related_name}__{column}[__{optional_next} etc.] . 1 2 3 4 5 6 7 8 9 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None fields() can be called several times, building up the columns to select. If you include related models into select_related() call but you won't specify columns for those models in fields - implies a list of all fields for those nested models. 1 2 3 4 5 all_cars = await Car . objects . select_related ( 'manufacturer' ) . fields ( 'id' ) . fields ( [ 'name' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. You cannot exclude mandatory model columns - manufacturer__name in this example. 1 2 await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__founded' ]) . all () # will raise pydantic ValidationError as company.name is required Tip Pk column cannot be excluded - it's always auto added even if not explicitly included. You can also pass fields to include as dictionary or set. To mark a field as included in a dictionary use it's name as key and ellipsis as value. To traverse nested models use nested dictionaries. To include fields at last level instead of nested dictionary a set can be used. To include whole nested model specify model related field name and ellipsis. Below you can see examples that are equivalent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 1. like in example above await Car . objects . select_related ( 'manufacturer' ) . fields ([ 'id' , 'name' , 'manufacturer__name' ]) . all () # 2. to mark a field as required use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' : ... } }) . all () # 3. to include whole nested model use ellipsis await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : ... }) . all () # 4. to specify fields at last nesting level you can also use set - equivalent to 2. above await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' } }) . all () # 5. of course set can have multiple fields await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'name' , 'founded' } }) . all () # 6. you can include all nested fields but it will be equivalent of 3. above which is shorter await Car . objects . select_related ( 'manufacturer' ) . fields ({ 'id' : ... , 'name' : ... , 'manufacturer' : { 'id' , 'name' , 'founded' } }) . all () Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"fields"},{"location":"queries/#exclude_fields","text":"exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet With exclude_fields() you can select subset of model columns that will be excluded to limit the data load. It's the opposite of fields() method so check documentation above to see what options are available. Especially check above how you can pass also nested dictionaries and sets as a mask to exclude fields from whole hierarchy. Note Note that fields() and exclude_fields() works both for main models (on normal queries like get , all etc.) as well as select_related and prefetch_related models (with nested notation). Below you can find few simple examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Company ( ormar . Model ): class Meta : tablename = \"companies\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) founded : int = ormar . Integer ( nullable = True ) class Car ( ormar . Model ): class Meta : tablename = \"cars\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) manufacturer = ormar . ForeignKey ( Company ) name : str = ormar . String ( max_length = 100 ) year : int = ormar . Integer ( nullable = True ) gearbox_type : str = ormar . String ( max_length = 20 , nullable = True ) gears : int = ormar . Integer ( nullable = True ) aircon_type : str = ormar . String ( max_length = 20 , nullable = True ) # build some sample data toyota = await Company . objects . create ( name = \"Toyota\" , founded = 1937 ) await Car . objects . create ( manufacturer = toyota , name = \"Corolla\" , year = 2020 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Yaris\" , year = 2019 , gearbox_type = 'Manual' , gears = 5 , aircon_type = 'Manual' ) await Car . objects . create ( manufacturer = toyota , name = \"Supreme\" , year = 2020 , gearbox_type = 'Auto' , gears = 6 , aircon_type = 'Auto' ) # select manufacturer but only name - to include related models use notation {model_name}__{column} all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' , 'company__founded' ]) . all () for car in all_cars : # excluded columns will yield None assert all ( getattr ( car , x ) is None for x in [ 'year' , 'gearbox_type' , 'gears' , 'aircon_type' ]) # included column on related models will be available, pk column is always included # even if you do not include it in fields list assert car . manufacturer . name == 'Toyota' # also in the nested related models - you cannot exclude pk - it's always auto added assert car . manufacturer . founded is None # fields() can be called several times, building up the columns to select # models selected in select_related but with no columns in fields list implies all fields all_cars = await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ( 'year' ) . exclude_fields ( [ 'gear' , 'gearbox_type' ]) . all () # all fiels from company model are selected assert all_cars [ 0 ] . manufacturer . name == 'Toyota' assert all_cars [ 0 ] . manufacturer . founded == 1937 # cannot exclude mandatory model columns - company__name in this example - note usage of dict/set this time await Car . objects . select_related ( 'manufacturer' ) . exclude_fields ([{ 'company' : { 'name' }}]) . all () # will raise pydantic ValidationError as company.name is required Warning Mandatory fields cannot be excluded as it will raise ValidationError , to exclude a field it has to be nullable. Tip Pk column cannot be excluded - it's always auto added even if explicitly excluded. Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"exclude_fields"},{"location":"queries/#order_by","text":"order_by(columns: Union[List, str]) -> QuerySet With order_by() you can order the results from database based on your choice of fields. You can provide a string with field name or list of strings with different fields. Ordering in sql will be applied in order of names you provide in order_by. Tip By default if you do not provide ordering ormar explicitly orders by all primary keys Warning If you are sorting by nested models that causes that the result rows are unsorted by the main model ormar will combine those children rows into one main model. Sample raw database rows result (sort by child model desc): 1 2 3 MODEL: 1 - Child Model - 3 MODEL: 2 - Child Model - 2 MODEL: 1 - Child Model - 1 will result in 2 rows of result: 1 2 MODEL: 1 - Child Models: [3, 1] # encountered first in result, all children rows combined MODEL: 2 - Child Modles: [2] The main model will never duplicate in the result Given sample Models like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import databases import sqlalchemy import ormar from tests.settings import DATABASE_URL database = databases . Database ( DATABASE_URL , force_rollback = True ) metadata = sqlalchemy . MetaData () class Owner ( ormar . Model ): class Meta : tablename = \"owners\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Toy ( ormar . Model ): class Meta : tablename = \"toys\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) owner : Owner = ormar . ForeignKey ( Owner ) # build some sample data aphrodite = await Owner . objects . create ( name = \"Aphrodite\" ) hermes = await Owner . objects . create ( name = \"Hermes\" ) zeus = await Owner . objects . create ( name = \"Zeus\" ) await Toy . objects . create ( name = \"Toy 4\" , owner = zeus ) await Toy . objects . create ( name = \"Toy 5\" , owner = hermes ) await Toy . objects . create ( name = \"Toy 2\" , owner = aphrodite ) await Toy . objects . create ( name = \"Toy 1\" , owner = zeus ) await Toy . objects . create ( name = \"Toy 3\" , owner = aphrodite ) await Toy . objects . create ( name = \"Toy 6\" , owner = hermes ) To order by main model field just provide a field name 1 2 3 4 5 6 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"name\" ) . all () assert [ x . name . replace ( \"Toy \" , \"\" ) for x in toys ] == [ str ( x + 1 ) for x in range ( 6 ) ] assert toys [ 0 ] . owner == zeus assert toys [ 1 ] . owner == aphrodite To sort on nested models separate field names with dunder '__'. You can sort this way across all relation types -> ForeignKey , reverse virtual FK and ManyToMany fields. 1 2 3 4 toys = await Toy . objects . select_related ( \"owner\" ) . order_by ( \"owner__name\" ) . all () assert toys [ 0 ] . owner . name == toys [ 1 ] . owner . name == \"Aphrodite\" assert toys [ 2 ] . owner . name == toys [ 3 ] . owner . name == \"Hermes\" assert toys [ 4 ] . owner . name == toys [ 5 ] . owner . name == \"Zeus\" To sort in descending order provide a hyphen in front of the field name 1 2 3 4 5 6 7 8 owner = ( await Owner . objects . select_related ( \"toys\" ) . order_by ( \"-toys__name\" ) . filter ( name = \"Zeus\" ) . get () ) assert owner . toys [ 0 ] . name == \"Toy 4\" assert owner . toys [ 1 ] . name == \"Toy 1\" Note All methods that do not return the rows explicitly returns a QueySet instance so you can chain them together So operations like filter() , select_related() , limit() and offset() etc. can be chained. Something like Track.object.select_related(\"album\").filter(album__name=\"Malibu\").offset(1).limit(1).all()","title":"order_by"},{"location":"relations/","text":"Relations Defining a relationship ForeignKey ForeignKey(to, related_name=None) has required parameters to that takes target Model class. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model Defining Models To define a relation add ForeignKey field that points to related Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) Reverse Relation ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Reverse relation exposes API to manage related objects also from parent side. add Adding child model from parent side causes adding related model to currently loaded parent relation, as well as sets child's model foreign key value and updates the model. 1 2 3 4 5 6 7 8 9 department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False ) # note - not saved await department . courses . add ( course ) assert course . pk is not None # child model was saved # relation on child model is set and FK column saved in db assert courses . department == department # relation on parent model is also set assert department . courses [ 0 ] == course Warning If you want to add child model on related model the primary key value for parent model has to exist in database . Otherwise ormar will raise RelationshipInstanceError as it cannot set child's ForeignKey column value if parent model has no primary key value. That means that in example above the department has to be saved before you can call department.courses.add() . remove Removal of the related model one by one. In reverse relation calling remove() does not remove the child model, but instead nulls it ForeignKey value. 1 2 3 4 5 6 7 8 9 # continuing from above await department . courses . remove ( course ) assert len ( department . courses ) == 0 # course still exists and was saved in remove assert course . pk is not None assert course . department is None # to remove child from db await course . delete () But if you want to clear the relation and delete the child at the same time you can issue: 1 2 3 # this will not only clear the relation # but also delete related course from db await department . courses . remove ( course , keep_reversed = False ) clear Removal of all related models in one call. Like remove by default clear() nulls the ForeigKey column on child model (all, not matter if they are loaded or not). 1 2 # nulls department column on all courses related to this department await department . courses . clear () If you want to remove the children altogether from the database, set keep_reversed=False 1 2 # deletes from db all courses related to this department await department . courses . clear ( keep_reversed = False ) QuerysetProxy Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy related_name But you can overwrite this name by providing related_name parameter like below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department , related_name = \"my_courses\" ) department = Department ( name = \"Science\" ) course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . my_courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Tip The reverse relation on access returns list of wekref.proxy to avoid circular references. Relation Setup You have several ways to set-up a relationship connection. Model instance The most obvious one is to pass a related Model instance to the constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Primary key value You can setup the relation also with just the pk column value of the related model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Dictionary Next option is with a dictionary of key-values of the related model. You can build the dictionary yourself or get it from existing model with dict() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) None Finally you can explicitly set it to None (default behavior if no value passed). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library. ManyToMany ManyToMany(to, through) has required parameters to and through that takes target and relation Model classes. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model Defining Models 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from typing import Optional , Union , List import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Author ( ormar . Model ): class Meta : tablename = \"authors\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta : tablename = \"posts_categories\" database = database metadata = metadata # If there are no additional columns id will be created automatically as Integer class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) Create sample data: 1 2 3 guido = await Author . objects . create ( first_name = \"Guido\" , last_name = \"Van Rossum\" ) post = await Post . objects . create ( title = \"Hello, M2M\" , author = guido ) news = await Category . objects . create ( name = \"News\" ) add 1 2 3 4 # Add a category to a post. await post . categories . add ( news ) # or from the other end: await news . posts . add ( post ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library. remove Removal of the related model one by one. Removes also the relation in the database. 1 await news . posts . remove ( post ) clear Removal of all related models in one call. Removes also the relation in the database. 1 await news . posts . clear () QuerysetProxy Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy QuerySetProxy When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Note By default exposed QuerySet is already filtered to return only Models related to parent Model . So if you issue post.categories.all() you will get all categories related to that post, not all in table. Note Note that when accessing QuerySet API methods through QuerysetProxy you don't need to use objects attribute like in normal queries. So note that it's post.categories.all() and not post.categories.objects.all() . To learn more about available QuerySet methods visit queries Warning Querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 This happens for all QuerysetProxy methods returning data: get , all and first and in get_or_create if model already exists. Note that value returned by create or created in get_or_create and update_or_create if model does not exist will be added to relation list (not clearing it). get get(**kwargs): -> Model To grab just one of related models filtered by name you can use get(**kwargs) method. 1 2 3 4 5 6 7 8 9 # grab one category assert news == await post . categories . get ( name = \"News\" ) # note that method returns the category so you can grab this value # but it also modifies list of related models in place # so regardless of what was previously loaded on parent model # now it has only one value -> just loaded with get() call assert len ( post . categories ) == 1 assert post . categories [ 0 ] == news Tip Read more in queries documentation get all all(**kwargs) -> List[Optional[\"Model\"]] To get a list of related models use all() method. Note that you can filter the queryset, select related, exclude fields etc. like in normal query. 1 2 3 4 5 6 7 # with all Queryset methods - filtering, selecting columns, counting etc. await news . posts . filter ( title__contains = \"M2M\" ) . all () await Category . objects . filter ( posts__author = guido ) . get () # columns models of many to many relation can be prefetched news_posts = await news . posts . select_related ( \"author\" ) . all () assert news_posts [ 0 ] . author == guido Tip Read more in queries documentation all create create(**kwargs): -> Model Create related Model directly from parent Model . The link table is automatically populated, as well as relation ids in the database. 1 2 3 4 # Creating columns object from instance: await post . categories . create ( name = \"Tips\" ) assert len ( await post . categories . all ()) == 2 # newly created instance already have relation persisted in the database Tip Read more in queries documentation create get_or_create get_or_create(**kwargs) -> Model Tip Read more in queries documentation get_or_create update_or_create update_or_create(**kwargs) -> Model Tip Read more in queries documentation update_or_create filter filter(**kwargs) -> QuerySet Tip Read more in queries documentation filter exclude exclude(**kwargs) -> QuerySet Tip Read more in queries documentation exclude select_related select_related(related: Union[List, str]) -> QuerySet Tip Read more in queries documentation select_related prefetch_related prefetch_related(related: Union[List, str]) -> QuerySet Tip Read more in queries documentation prefetch_related limit limit(limit_count: int) -> QuerySet Tip Read more in queries documentation limit offset offset(offset: int) -> QuerySet Tip Read more in queries documentation offset count count() -> int Tip Read more in queries documentation count exists exists() -> bool Tip Read more in queries documentation exists fields fields(columns: Union[List, str, set, dict]) -> QuerySet Tip Read more in queries documentation fields exclude_fields exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet Tip Read more in queries documentation exclude_fields order_by order_by(columns:Union[List, str]) -> QuerySet Tip Read more in queries documentation order_by","title":"Relations"},{"location":"relations/#relations","text":"","title":"Relations"},{"location":"relations/#defining-a-relationship","text":"","title":"Defining a relationship"},{"location":"relations/#foreignkey","text":"ForeignKey(to, related_name=None) has required parameters to that takes target Model class. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model","title":"ForeignKey"},{"location":"relations/#defining-models","text":"To define a relation add ForeignKey field that points to related Model . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department )","title":"Defining Models"},{"location":"relations/#reverse-relation","text":"ForeignKey fields are automatically registering reverse side of the relation. By default it's child (source) Model name + s, like courses in snippet below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department ) department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Reverse relation exposes API to manage related objects also from parent side.","title":"Reverse Relation"},{"location":"relations/#add","text":"Adding child model from parent side causes adding related model to currently loaded parent relation, as well as sets child's model foreign key value and updates the model. 1 2 3 4 5 6 7 8 9 department = await Department ( name = \"Science\" ) . save () course = Course ( name = \"Math\" , completed = False ) # note - not saved await department . courses . add ( course ) assert course . pk is not None # child model was saved # relation on child model is set and FK column saved in db assert courses . department == department # relation on parent model is also set assert department . courses [ 0 ] == course Warning If you want to add child model on related model the primary key value for parent model has to exist in database . Otherwise ormar will raise RelationshipInstanceError as it cannot set child's ForeignKey column value if parent model has no primary key value. That means that in example above the department has to be saved before you can call department.courses.add() .","title":"add"},{"location":"relations/#remove","text":"Removal of the related model one by one. In reverse relation calling remove() does not remove the child model, but instead nulls it ForeignKey value. 1 2 3 4 5 6 7 8 9 # continuing from above await department . courses . remove ( course ) assert len ( department . courses ) == 0 # course still exists and was saved in remove assert course . pk is not None assert course . department is None # to remove child from db await course . delete () But if you want to clear the relation and delete the child at the same time you can issue: 1 2 3 # this will not only clear the relation # but also delete related course from db await department . courses . remove ( course , keep_reversed = False )","title":"remove"},{"location":"relations/#clear","text":"Removal of all related models in one call. Like remove by default clear() nulls the ForeigKey column on child model (all, not matter if they are loaded or not). 1 2 # nulls department column on all courses related to this department await department . courses . clear () If you want to remove the children altogether from the database, set keep_reversed=False 1 2 # deletes from db all courses related to this department await department . courses . clear ( keep_reversed = False )","title":"clear"},{"location":"relations/#querysetproxy","text":"Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy","title":"QuerysetProxy"},{"location":"relations/#related_name","text":"But you can overwrite this name by providing related_name parameter like below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from typing import Optional import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Department ] = ormar . ForeignKey ( Department , related_name = \"my_courses\" ) department = Department ( name = \"Science\" ) course = Course ( name = \"Math\" , completed = False , department = department ) print ( department . my_courses [ 0 ]) # Will produce: # Course(id=None, # name='Math', # completed=False, # department=Department(id=None, name='Science')) Tip The reverse relation on access returns list of wekref.proxy to avoid circular references.","title":"related_name"},{"location":"relations/#relation-setup","text":"You have several ways to set-up a relationship connection.","title":"Relation Setup"},{"location":"relations/#model-instance","text":"The most obvious one is to pass a related Model instance to the constructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Model instance"},{"location":"relations/#primary-key-value","text":"You can setup the relation also with just the pk column value of the related model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Primary key value"},{"location":"relations/#dictionary","text":"Next option is with a dictionary of key-values of the related model. You can build the dictionary yourself or get it from existing model with dict() method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None )","title":"Dictionary"},{"location":"relations/#none","text":"Finally you can explicitly set it to None (default behavior if no value passed). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from typing import Optional , Dict , Union import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Department ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) class Course ( ormar . Model ): class Meta : database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) completed : bool = ormar . Boolean ( default = False ) department : Optional [ Union [ Department , Dict ]] = ormar . ForeignKey ( Department ) department = Department ( name = \"Science\" ) # set up a relation with actual Model instance course = Course ( name = \"Math\" , completed = False , department = department ) # set up relation with only related model pk value course2 = Course ( name = \"Math II\" , completed = False , department = department . pk ) # set up a relation with dictionary corresponding to related model course3 = Course ( name = \"Math III\" , completed = False , department = department . dict ()) # explicitly set up None course4 = Course ( name = \"Math III\" , completed = False , department = None ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library.","title":"None"},{"location":"relations/#manytomany","text":"ManyToMany(to, through) has required parameters to and through that takes target and relation Model classes. Sqlalchemy column and Type are automatically taken from target Model . Sqlalchemy column: class of a target Model primary key column Type (used for pydantic): type of a target Model","title":"ManyToMany"},{"location":"relations/#defining-models_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from typing import Optional , Union , List import databases import ormar import sqlalchemy database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Author ( ormar . Model ): class Meta : tablename = \"authors\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) first_name : str = ormar . String ( max_length = 80 ) last_name : str = ormar . String ( max_length = 80 ) class Category ( ormar . Model ): class Meta : tablename = \"categories\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 40 ) class PostCategory ( ormar . Model ): class Meta : tablename = \"posts_categories\" database = database metadata = metadata # If there are no additional columns id will be created automatically as Integer class Post ( ormar . Model ): class Meta : tablename = \"posts\" database = database metadata = metadata id : int = ormar . Integer ( primary_key = True ) title : str = ormar . String ( max_length = 200 ) categories : Optional [ Union [ Category , List [ Category ]]] = ormar . ManyToMany ( Category , through = PostCategory ) author : Optional [ Author ] = ormar . ForeignKey ( Author ) Create sample data: 1 2 3 guido = await Author . objects . create ( first_name = \"Guido\" , last_name = \"Van Rossum\" ) post = await Post . objects . create ( title = \"Hello, M2M\" , author = guido ) news = await Category . objects . create ( name = \"News\" )","title":"Defining Models"},{"location":"relations/#add_1","text":"1 2 3 4 # Add a category to a post. await post . categories . add ( news ) # or from the other end: await news . posts . add ( post ) Warning In all not None cases the primary key value for related model has to exist in database . Otherwise an IntegrityError will be raised by your database driver library.","title":"add"},{"location":"relations/#remove_1","text":"Removal of the related model one by one. Removes also the relation in the database. 1 await news . posts . remove ( post )","title":"remove"},{"location":"relations/#clear_1","text":"Removal of all related models in one call. Removes also the relation in the database. 1 await news . posts . clear ()","title":"clear"},{"location":"relations/#querysetproxy_1","text":"Reverse relation exposes QuerysetProxy API that allows you to query related model like you would issue a normal Query. To read which methods of QuerySet are available read below querysetproxy","title":"QuerysetProxy"},{"location":"relations/#querysetproxy_2","text":"When access directly the related ManyToMany field as well as ReverseForeignKey returns the list of related models. But at the same time it exposes subset of QuerySet API, so you can filter, create, select related etc related models directly from parent model. Note By default exposed QuerySet is already filtered to return only Models related to parent Model . So if you issue post.categories.all() you will get all categories related to that post, not all in table. Note Note that when accessing QuerySet API methods through QuerysetProxy you don't need to use objects attribute like in normal queries. So note that it's post.categories.all() and not post.categories.objects.all() . To learn more about available QuerySet methods visit queries Warning Querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 This happens for all QuerysetProxy methods returning data: get , all and first and in get_or_create if model already exists. Note that value returned by create or created in get_or_create and update_or_create if model does not exist will be added to relation list (not clearing it).","title":"QuerySetProxy"},{"location":"relations/#get","text":"get(**kwargs): -> Model To grab just one of related models filtered by name you can use get(**kwargs) method. 1 2 3 4 5 6 7 8 9 # grab one category assert news == await post . categories . get ( name = \"News\" ) # note that method returns the category so you can grab this value # but it also modifies list of related models in place # so regardless of what was previously loaded on parent model # now it has only one value -> just loaded with get() call assert len ( post . categories ) == 1 assert post . categories [ 0 ] == news Tip Read more in queries documentation get","title":"get"},{"location":"relations/#all","text":"all(**kwargs) -> List[Optional[\"Model\"]] To get a list of related models use all() method. Note that you can filter the queryset, select related, exclude fields etc. like in normal query. 1 2 3 4 5 6 7 # with all Queryset methods - filtering, selecting columns, counting etc. await news . posts . filter ( title__contains = \"M2M\" ) . all () await Category . objects . filter ( posts__author = guido ) . get () # columns models of many to many relation can be prefetched news_posts = await news . posts . select_related ( \"author\" ) . all () assert news_posts [ 0 ] . author == guido Tip Read more in queries documentation all","title":"all"},{"location":"relations/#create","text":"create(**kwargs): -> Model Create related Model directly from parent Model . The link table is automatically populated, as well as relation ids in the database. 1 2 3 4 # Creating columns object from instance: await post . categories . create ( name = \"Tips\" ) assert len ( await post . categories . all ()) == 2 # newly created instance already have relation persisted in the database Tip Read more in queries documentation create","title":"create"},{"location":"relations/#get_or_create","text":"get_or_create(**kwargs) -> Model Tip Read more in queries documentation get_or_create","title":"get_or_create"},{"location":"relations/#update_or_create","text":"update_or_create(**kwargs) -> Model Tip Read more in queries documentation update_or_create","title":"update_or_create"},{"location":"relations/#filter","text":"filter(**kwargs) -> QuerySet Tip Read more in queries documentation filter","title":"filter"},{"location":"relations/#exclude","text":"exclude(**kwargs) -> QuerySet Tip Read more in queries documentation exclude","title":"exclude"},{"location":"relations/#select_related","text":"select_related(related: Union[List, str]) -> QuerySet Tip Read more in queries documentation select_related","title":"select_related"},{"location":"relations/#prefetch_related","text":"prefetch_related(related: Union[List, str]) -> QuerySet Tip Read more in queries documentation prefetch_related","title":"prefetch_related"},{"location":"relations/#limit","text":"limit(limit_count: int) -> QuerySet Tip Read more in queries documentation limit","title":"limit"},{"location":"relations/#offset","text":"offset(offset: int) -> QuerySet Tip Read more in queries documentation offset","title":"offset"},{"location":"relations/#count","text":"count() -> int Tip Read more in queries documentation count","title":"count"},{"location":"relations/#exists","text":"exists() -> bool Tip Read more in queries documentation exists","title":"exists"},{"location":"relations/#fields","text":"fields(columns: Union[List, str, set, dict]) -> QuerySet Tip Read more in queries documentation fields","title":"fields"},{"location":"relations/#exclude_fields","text":"exclude_fields(columns: Union[List, str, set, dict]) -> QuerySet Tip Read more in queries documentation exclude_fields","title":"exclude_fields"},{"location":"relations/#order_by","text":"order_by(columns:Union[List, str]) -> QuerySet Tip Read more in queries documentation order_by","title":"order_by"},{"location":"releases/","text":"0.7.5 Fix for wrong relation column name in many_to_many relation joins (fix #73 ) 0.7.4 Allow multiple relations to the same related model/table. Fix for wrong relation column used in many_to_many relation joins (fix #73 ) Fix for wrong relation population for m2m relations when also fk relation present for same model. Add check if user provide related_name if there are multiple relations to same table on one model. More eager cleaning of the dead weak proxy models. 0.7.3 Fix for setting fetching related model with UUDI pk, which is a string in raw (fix #71 ) 0.7.2 Fix for overwriting related models with pk only in Model.update() with fields passed as parameters (fix #70 ) 0.7.1 Fix for overwriting related models with pk only in Model.save() (fix #68 ) 0.7.0 Breaking: QuerySet bulk_update method now raises ModelPersistenceError for unsaved models passed instead of QueryDefinitionError Breaking: Model initialization with unknown field name now raises ModelError instead of KeyError Added Signals , with pre-defined list signals and decorators: post_delete , post_save , post_update , pre_delete , pre_save , pre_update Add py.typed and modify setup.py for mypy support Performance optimization Updated docs 0.6.2 Performance optimization Fix for bug with pydantic_only fields being required Add property_field decorator that registers a function as a property that will be included in Model.dict() and in fastapi response Update docs 0.6.1 Explicitly set None to excluded nullable fields to avoid pydantic setting a default value (fix #60 ). 0.6.0 Breaking: calling instance.load() when the instance row was deleted from db now raises NoMatch instead of ValueError Breaking: calling add and remove on ReverseForeignKey relation now updates the child model in db setting/removing fk column Breaking: ReverseForeignKey relation now exposes QuerySetProxy API like ManyToMany relation Breaking: querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 Added get_or_create , update_or_create , fields , exclude_fields , exclude , prefetch_related and order_by to QuerySetProxy so now you can use those methods directly from relation Update docs 0.5.5 Fix for alembic autogenaration of migration UUID columns. It should just produce sqlalchemy CHAR(32) or CHAR(36) In order for this to work you have to set user_module_prefix='sa.' (must be equal to sqlalchemy_module_prefix option (default 'sa.')) 0.5.4 Allow to pass uuid_format (allowed 'hex'(default) or 'string') to UUID field to change the format in which it's saved. By default field is saved in hex format (trimmed to 32 chars (without dashes)), but you can pass format='string' to use 36 (with dashes) instead to adjust to existing db or other libraries. Sample: * hex value = c616ab438cce49dbbf4380d109251dce * string value = c616ab43-8cce-49db-bf43-80d109251dce 0.5.3 Fixed bug in Model.dict() method that was ignoring exclude parameter and not include dictionary argument. 0.5.2 Added prefetch_related method to load subsequent models in separate queries. Update docs 0.5.1 Switched to github actions instead of travis Update badges in the docs 0.5.0 Added save status -> you can check if model is saved with ModelInstance.saved property Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantation with __init__ (w/o QuerySet.create or before calling save ) Added Model.upsert(**kwargs) that performs save() if pk not set otherwise update(**kwargs) Added Model.save_related(follow=False) that iterates all related objects in all relations and checks if they are saved. If not it calls upsert() on each of them. Breaking: added raising exceptions if add -ing/ remove -ing not saved (pk is None) models to ManyToMany relation Allow passing dictionaries and sets to fields and exclude_fields Auto translate str and lists to dicts for fields and exclude_fields Breaking: passing nested models to fields and exclude_fields is now by related ForeignKey name and not by target model name Performance optimizations - in modelproxy, newbasemodel - > less queries, some properties are cached on models Cleanup of unused relations code Optional performance dependency orjson added ( strongly recommended ) Updated docs 0.4.4 add exclude_fields() method to exclude fields from sql refactor column names setting (aliases) fix ordering by for column with aliases additional tests for fields and exclude_fields update docs 0.4.3 include properties in models.dict() and model.json() 0.4.2 modify creation of pydantic models to allow returning related models with only pk populated 0.4.1 add order_by method to queryset to allow sorting update docs 0.4.0 Changed notation in Model definition -> now use name = ormar.Field() not name: ormar.Field() Note that old notation is still supported but deprecated and will not play nice with static checkers like mypy and pydantic pycharm plugin Type hint docs and test Use mypy for tests also not, only ormar package Fix scale and precision translation with max_digits and decimal_places pydantic Decimal field Update docs - add best practices for dependencies Refactor metaclass and model_fields to play nice with type hints Add mypy and pydantic plugin to docs Expand the docs on ManyToMany relation 0.3.11 Fix setting server_default as default field value in python 0.3.10 Fix postgresql check to avoid exceptions with drivers not installed if using different backend 0.3.9 Fix json schema generation as of #19 Fix for not initialized ManyToMany relations in fastapi copies of ormar.Models Update docs in regard of fastapi use Add tests to verify fastapi/docs proper generation 0.3.8 Added possibility to provide alternative database column names with name parameter to all fields. Fix bug with selecting related ManyToMany fields with fields() if they are empty. Updated documentation 0.3.7 Publish documentation and update readme 0.3.6 Add fields() method to limit the selected columns from database - only nullable columns can be excluded. Added UniqueColumns and constraints list in model Meta to build unique constraints on list of columns. Added UUID field type based on Char(32) column type. 0.3.5 Added bulk_create and bulk_update for operations on multiple objects. 0.3.4 Add queryset level methods * delete * update * get_or_create * update_or_create 0.3.3 Add additional filters - startswith and endswith 0.3.2 Add choices parameter to all fields - limiting the accepted values to ones provided 0.3.1 Added exclude to filter where not conditions. Added tests for mysql and postgres with fixes for postgres. Rafactors and cleanup. 0.3.0 Added ManyToMany field and support for many to many relations","title":"Release Notes"},{"location":"releases/#075","text":"Fix for wrong relation column name in many_to_many relation joins (fix #73 )","title":"0.7.5"},{"location":"releases/#074","text":"Allow multiple relations to the same related model/table. Fix for wrong relation column used in many_to_many relation joins (fix #73 ) Fix for wrong relation population for m2m relations when also fk relation present for same model. Add check if user provide related_name if there are multiple relations to same table on one model. More eager cleaning of the dead weak proxy models.","title":"0.7.4"},{"location":"releases/#073","text":"Fix for setting fetching related model with UUDI pk, which is a string in raw (fix #71 )","title":"0.7.3"},{"location":"releases/#072","text":"Fix for overwriting related models with pk only in Model.update() with fields passed as parameters (fix #70 )","title":"0.7.2"},{"location":"releases/#071","text":"Fix for overwriting related models with pk only in Model.save() (fix #68 )","title":"0.7.1"},{"location":"releases/#070","text":"Breaking: QuerySet bulk_update method now raises ModelPersistenceError for unsaved models passed instead of QueryDefinitionError Breaking: Model initialization with unknown field name now raises ModelError instead of KeyError Added Signals , with pre-defined list signals and decorators: post_delete , post_save , post_update , pre_delete , pre_save , pre_update Add py.typed and modify setup.py for mypy support Performance optimization Updated docs","title":"0.7.0"},{"location":"releases/#062","text":"Performance optimization Fix for bug with pydantic_only fields being required Add property_field decorator that registers a function as a property that will be included in Model.dict() and in fastapi response Update docs","title":"0.6.2"},{"location":"releases/#061","text":"Explicitly set None to excluded nullable fields to avoid pydantic setting a default value (fix #60 ).","title":"0.6.1"},{"location":"releases/#060","text":"Breaking: calling instance.load() when the instance row was deleted from db now raises NoMatch instead of ValueError Breaking: calling add and remove on ReverseForeignKey relation now updates the child model in db setting/removing fk column Breaking: ReverseForeignKey relation now exposes QuerySetProxy API like ManyToMany relation Breaking: querying related models from ManyToMany cleans list of related models loaded on parent model: Example: post.categories.first() will set post.categories to list of 1 related model -> the one returned by first() Example 2: if post has 4 categories so len(post.categories) == 4 calling post.categories.limit(2).all() -> will load only 2 children and now assert len(post.categories) == 2 Added get_or_create , update_or_create , fields , exclude_fields , exclude , prefetch_related and order_by to QuerySetProxy so now you can use those methods directly from relation Update docs","title":"0.6.0"},{"location":"releases/#055","text":"Fix for alembic autogenaration of migration UUID columns. It should just produce sqlalchemy CHAR(32) or CHAR(36) In order for this to work you have to set user_module_prefix='sa.' (must be equal to sqlalchemy_module_prefix option (default 'sa.'))","title":"0.5.5"},{"location":"releases/#054","text":"Allow to pass uuid_format (allowed 'hex'(default) or 'string') to UUID field to change the format in which it's saved. By default field is saved in hex format (trimmed to 32 chars (without dashes)), but you can pass format='string' to use 36 (with dashes) instead to adjust to existing db or other libraries. Sample: * hex value = c616ab438cce49dbbf4380d109251dce * string value = c616ab43-8cce-49db-bf43-80d109251dce","title":"0.5.4"},{"location":"releases/#053","text":"Fixed bug in Model.dict() method that was ignoring exclude parameter and not include dictionary argument.","title":"0.5.3"},{"location":"releases/#052","text":"Added prefetch_related method to load subsequent models in separate queries. Update docs","title":"0.5.2"},{"location":"releases/#051","text":"Switched to github actions instead of travis Update badges in the docs","title":"0.5.1"},{"location":"releases/#050","text":"Added save status -> you can check if model is saved with ModelInstance.saved property Model is saved after save/update/load/upsert method on model Model is saved after create/get/first/all/get_or_create/update_or_create method Model is saved when passed to bulk_update and bulk_create Model is saved after adding/removing ManyToMany related objects (through model instance auto saved/deleted) Model is not saved after change of any own field (including pk as Model.pk alias) Model is not saved after adding/removing ForeignKey related object (fk column not saved) Model is not saved after instantation with __init__ (w/o QuerySet.create or before calling save ) Added Model.upsert(**kwargs) that performs save() if pk not set otherwise update(**kwargs) Added Model.save_related(follow=False) that iterates all related objects in all relations and checks if they are saved. If not it calls upsert() on each of them. Breaking: added raising exceptions if add -ing/ remove -ing not saved (pk is None) models to ManyToMany relation Allow passing dictionaries and sets to fields and exclude_fields Auto translate str and lists to dicts for fields and exclude_fields Breaking: passing nested models to fields and exclude_fields is now by related ForeignKey name and not by target model name Performance optimizations - in modelproxy, newbasemodel - > less queries, some properties are cached on models Cleanup of unused relations code Optional performance dependency orjson added ( strongly recommended ) Updated docs","title":"0.5.0"},{"location":"releases/#044","text":"add exclude_fields() method to exclude fields from sql refactor column names setting (aliases) fix ordering by for column with aliases additional tests for fields and exclude_fields update docs","title":"0.4.4"},{"location":"releases/#043","text":"include properties in models.dict() and model.json()","title":"0.4.3"},{"location":"releases/#042","text":"modify creation of pydantic models to allow returning related models with only pk populated","title":"0.4.2"},{"location":"releases/#041","text":"add order_by method to queryset to allow sorting update docs","title":"0.4.1"},{"location":"releases/#040","text":"Changed notation in Model definition -> now use name = ormar.Field() not name: ormar.Field() Note that old notation is still supported but deprecated and will not play nice with static checkers like mypy and pydantic pycharm plugin Type hint docs and test Use mypy for tests also not, only ormar package Fix scale and precision translation with max_digits and decimal_places pydantic Decimal field Update docs - add best practices for dependencies Refactor metaclass and model_fields to play nice with type hints Add mypy and pydantic plugin to docs Expand the docs on ManyToMany relation","title":"0.4.0"},{"location":"releases/#0311","text":"Fix setting server_default as default field value in python","title":"0.3.11"},{"location":"releases/#0310","text":"Fix postgresql check to avoid exceptions with drivers not installed if using different backend","title":"0.3.10"},{"location":"releases/#039","text":"Fix json schema generation as of #19 Fix for not initialized ManyToMany relations in fastapi copies of ormar.Models Update docs in regard of fastapi use Add tests to verify fastapi/docs proper generation","title":"0.3.9"},{"location":"releases/#038","text":"Added possibility to provide alternative database column names with name parameter to all fields. Fix bug with selecting related ManyToMany fields with fields() if they are empty. Updated documentation","title":"0.3.8"},{"location":"releases/#037","text":"Publish documentation and update readme","title":"0.3.7"},{"location":"releases/#036","text":"Add fields() method to limit the selected columns from database - only nullable columns can be excluded. Added UniqueColumns and constraints list in model Meta to build unique constraints on list of columns. Added UUID field type based on Char(32) column type.","title":"0.3.6"},{"location":"releases/#035","text":"Added bulk_create and bulk_update for operations on multiple objects.","title":"0.3.5"},{"location":"releases/#034","text":"Add queryset level methods * delete * update * get_or_create * update_or_create","title":"0.3.4"},{"location":"releases/#033","text":"Add additional filters - startswith and endswith","title":"0.3.3"},{"location":"releases/#032","text":"Add choices parameter to all fields - limiting the accepted values to ones provided","title":"0.3.2"},{"location":"releases/#031","text":"Added exclude to filter where not conditions. Added tests for mysql and postgres with fixes for postgres. Rafactors and cleanup.","title":"0.3.1"},{"location":"releases/#030","text":"Added ManyToMany field and support for many to many relations","title":"0.3.0"},{"location":"signals/","text":"Signals Signals are a mechanism to fire your piece of code (function / method) whenever given type of event happens in ormar . To achieve this you need to register your receiver for a given type of signal for selected model(s). Defining receivers Given a sample model like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) You can for example define a trigger that will set album.is_best_seller status if it will be played more than 50 times. Import pre_update decorator, for list of currently available decorators/ signals check below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Define your function. Note that each receiver function: has to be callable has to accept first sender argument that receives the class of sending object has to accept **kwargs argument as the parameters send in each ormar.Signal can change at any time so your function has to serve them. has to be async cause callbacks are gathered and awaited. pre_update currently sends only one argument apart from sender and it's instance one. Note how pre_update decorator accepts a senders argument that can be a single model or a list of models, for which you want to run the signal receiver. Currently there is no way to set signal for all models at once without explicitly passing them all into registration of receiver. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Note Note that receivers are defined on a class level -> so even if you connect/disconnect function through instance it will run/ stop running for all operations on that ormar.Model class. Note that our newly created function has instance and class of the instance so you can easily run database queries inside your receivers if you want to. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller You can define same receiver for multiple models at once by passing a list of models to signal decorator. 1 2 3 4 # define a dummy debug function @pre_update ([ Album , Track ]) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) Of course you can also create multiple functions for the same signal and model. Each of them will run at each signal. 1 2 3 4 5 6 7 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) @pre_update ( Album ) async def before_update2 ( sender , instance , ** kwargs ): print ( f 'About to update { sender . get_name () } with pk: { instance . pk } ' ) Note that ormar decorators are the syntactic sugar, you can directly connect your function or method for given signal for given model. Connect accept only one parameter - your receiver function / method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AlbumAuditor : def __init__ ( self ): self . event_type = \"ALBUM_INSTANCE\" async def before_save ( self , sender , instance , ** kwargs ): await AuditLog ( event_type = f \" { self . event_type } _SAVE\" , event_log = instance . json () ) . save () auditor = AlbumAuditor () pre_save ( Album )( auditor . before_save ) # call above has same result like the one below Album . Meta . signals . pre_save . connect ( auditor . before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . connect ( auditor . before_save ) Warning Note that signals keep the reference to your receiver (not a weakref ) so keep that in mind to avoid circular references. Disconnecting the receivers To disconnect the receiver and stop it for running for given model you need to disconnect it. 1 2 3 4 5 6 7 8 9 10 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # disconnect given function from signal for given Model Album . Meta . signals . pre_save . disconnect ( before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . disconnect ( before_save ) Available signals Warning Note that signals are not send for: bulk operations ( QuerySet.bulk_create and QuerySet.bulk_update ) as they are designed for speed. queyset table level operations ( QuerySet.update and QuerySet.delete ) as they run on the underlying tables (more lak raw sql update/delete operations) and do not have specific instance. pre_save pre_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be saved. post_save post_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model that was saved. pre_update pre_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model to be updated. post_update post_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was updated. pre_delete pre_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be deleted. post_delete post_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was deleted. Defining your own signals Note that you can create your own signals although you will have to send them manually in your code or subclass ormar.Model and trigger your signals there. Creating new signal is super easy. Following example will set a new signal with name your_custom_signal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) Album . Meta . signals . your_custom_signal = ormar . Signal () Album . Meta . signals . your_custom_signal . connect ( your_receiver_name ) Actually under the hood signal is a SignalEmitter instance that keeps a dictionary of know signals, and allows you to access them as attributes. When you try to access a signal that does not exist SignalEmitter will create one for you. So example above can be simplified to. The Signal will be created for you. 1 Album.Meta.signals.your_custom_signal.connect(your_receiver_name) Now to trigger this signal you need to call send method of the Signal. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album ) Note that sender is the only required parameter and it should be ormar Model class. Additional parameters have to be passed as keyword arguments. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album , my_param = True )","title":"Signals"},{"location":"signals/#signals","text":"Signals are a mechanism to fire your piece of code (function / method) whenever given type of event happens in ormar . To achieve this you need to register your receiver for a given type of signal for selected model(s).","title":"Signals"},{"location":"signals/#defining-receivers","text":"Given a sample model like following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) You can for example define a trigger that will set album.is_best_seller status if it will be played more than 50 times. Import pre_update decorator, for list of currently available decorators/ signals check below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Define your function. Note that each receiver function: has to be callable has to accept first sender argument that receives the class of sending object has to accept **kwargs argument as the parameters send in each ormar.Signal can change at any time so your function has to serve them. has to be async cause callbacks are gathered and awaited. pre_update currently sends only one argument apart from sender and it's instance one. Note how pre_update decorator accepts a senders argument that can be a single model or a list of models, for which you want to run the signal receiver. Currently there is no way to set signal for all models at once without explicitly passing them all into registration of receiver. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller Note Note that receivers are defined on a class level -> so even if you connect/disconnect function through instance it will run/ stop running for all operations on that ormar.Model class. Note that our newly created function has instance and class of the instance so you can easily run database queries inside your receivers if you want to. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from ormar import pre_update @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # here album.play_count ans is_best_seller get default values album = await Album . objects . create ( name = \"Venice\" ) assert not album . is_best_seller assert album . play_count == 0 album . play_count = 30 # here a trigger is called but play_count is too low await album . update () assert not album . is_best_seller album . play_count = 60 await album . update () assert album . is_best_seller You can define same receiver for multiple models at once by passing a list of models to signal decorator. 1 2 3 4 # define a dummy debug function @pre_update ([ Album , Track ]) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) Of course you can also create multiple functions for the same signal and model. Each of them will run at each signal. 1 2 3 4 5 6 7 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): print ( f \" { sender . get_name () } : { instance . json () } : { kwargs } \" ) @pre_update ( Album ) async def before_update2 ( sender , instance , ** kwargs ): print ( f 'About to update { sender . get_name () } with pk: { instance . pk } ' ) Note that ormar decorators are the syntactic sugar, you can directly connect your function or method for given signal for given model. Connect accept only one parameter - your receiver function / method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class AlbumAuditor : def __init__ ( self ): self . event_type = \"ALBUM_INSTANCE\" async def before_save ( self , sender , instance , ** kwargs ): await AuditLog ( event_type = f \" { self . event_type } _SAVE\" , event_log = instance . json () ) . save () auditor = AlbumAuditor () pre_save ( Album )( auditor . before_save ) # call above has same result like the one below Album . Meta . signals . pre_save . connect ( auditor . before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . connect ( auditor . before_save ) Warning Note that signals keep the reference to your receiver (not a weakref ) so keep that in mind to avoid circular references.","title":"Defining receivers"},{"location":"signals/#disconnecting-the-receivers","text":"To disconnect the receiver and stop it for running for given model you need to disconnect it. 1 2 3 4 5 6 7 8 9 10 @pre_update ( Album ) async def before_update ( sender , instance , ** kwargs ): if instance . play_count > 50 and not instance . is_best_seller : instance . is_best_seller = True # disconnect given function from signal for given Model Album . Meta . signals . pre_save . disconnect ( before_save ) # signals are also exposed on instance album = Album ( name = 'Miami' ) album . signals . pre_save . disconnect ( before_save )","title":"Disconnecting the receivers"},{"location":"signals/#available-signals","text":"Warning Note that signals are not send for: bulk operations ( QuerySet.bulk_create and QuerySet.bulk_update ) as they are designed for speed. queyset table level operations ( QuerySet.update and QuerySet.delete ) as they run on the underlying tables (more lak raw sql update/delete operations) and do not have specific instance.","title":"Available signals"},{"location":"signals/#pre_save","text":"pre_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be saved.","title":"pre_save"},{"location":"signals/#post_save","text":"post_save(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model that was saved.","title":"post_save"},{"location":"signals/#pre_update","text":"pre_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model to be updated.","title":"pre_update"},{"location":"signals/#post_update","text":"post_update(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was updated.","title":"post_update"},{"location":"signals/#pre_delete","text":"pre_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.save() and Model.objects.create() methods. sender is a ormar.Model class and instance is the model to be deleted.","title":"pre_delete"},{"location":"signals/#post_delete","text":"post_delete(sender: Type[\"Model\"], instance: \"Model\") Send for Model.update() method. sender is a ormar.Model class and instance is the model that was deleted.","title":"post_delete"},{"location":"signals/#defining-your-own-signals","text":"Note that you can create your own signals although you will have to send them manually in your code or subclass ormar.Model and trigger your signals there. Creating new signal is super easy. Following example will set a new signal with name your_custom_signal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import databases import sqlalchemy import ormar database = databases . Database ( \"sqlite:///db.sqlite\" ) metadata = sqlalchemy . MetaData () class Album ( ormar . Model ): class Meta : tablename = \"albums\" metadata = metadata database = database id : int = ormar . Integer ( primary_key = True ) name : str = ormar . String ( max_length = 100 ) is_best_seller : bool = ormar . Boolean ( default = False ) play_count : int = ormar . Integer ( default = 0 ) Album . Meta . signals . your_custom_signal = ormar . Signal () Album . Meta . signals . your_custom_signal . connect ( your_receiver_name ) Actually under the hood signal is a SignalEmitter instance that keeps a dictionary of know signals, and allows you to access them as attributes. When you try to access a signal that does not exist SignalEmitter will create one for you. So example above can be simplified to. The Signal will be created for you. 1 Album.Meta.signals.your_custom_signal.connect(your_receiver_name) Now to trigger this signal you need to call send method of the Signal. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album ) Note that sender is the only required parameter and it should be ormar Model class. Additional parameters have to be passed as keyword arguments. 1 await Album . Meta . signals . your_custom_signal . send ( sender = Album , my_param = True )","title":"Defining your own signals"}]}